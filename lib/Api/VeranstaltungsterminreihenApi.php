<?php
/**
 * VeranstaltungsterminreihenApi
 * PHP version 7.4
 *
 * @category Class
 * @package  OpenAPI\Client
 * @author   OpenAPI Generator team
 * @link     https://openapi-generator.tech
 */

/**
 * VEDA Bildungsmanager API
 *
 * Dokumentation der REST-Schnittstellen des VEDA Bildungsmanagers für die Version 2. Die Dokumentation zu speziellen Versionen kann über die Angabe des zusätzlichen Parameters \"group\" angezeigt werden. Beispiel: .../api/docs?group=v1 für die Dokumentation der Version 1, die aktuelle Version ist unter .../api/docs erreichbar.
 *
 * The version of the OpenAPI document: 2
 * Contact: info@veda.net
 * Generated by: https://openapi-generator.tech
 * OpenAPI Generator version: 6.6.0
 */

/**
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

namespace OpenAPI\Client\Api;

use GuzzleHttp\Client;
use GuzzleHttp\ClientInterface;
use GuzzleHttp\Exception\ConnectException;
use GuzzleHttp\Exception\RequestException;
use GuzzleHttp\Psr7\MultipartStream;
use GuzzleHttp\Psr7\Request;
use GuzzleHttp\RequestOptions;
use OpenAPI\Client\ApiException;
use OpenAPI\Client\Configuration;
use OpenAPI\Client\HeaderSelector;
use OpenAPI\Client\ObjectSerializer;

/**
 * VeranstaltungsterminreihenApi Class Doc Comment
 *
 * @category Class
 * @package  OpenAPI\Client
 * @author   OpenAPI Generator team
 * @link     https://openapi-generator.tech
 */
class VeranstaltungsterminreihenApi
{
    /**
     * @var ClientInterface
     */
    protected $client;

    /**
     * @var Configuration
     */
    protected $config;

    /**
     * @var HeaderSelector
     */
    protected $headerSelector;

    /**
     * @var int Host index
     */
    protected $hostIndex;

    /** @var string[] $contentTypes **/
    public const contentTypes = [
        'getVeranstaltungsterminreiheUsingGET' => [
            'application/json',
        ],
        'getVeranstaltungsterminreiheUsingGET1' => [
            'application/json',
        ],
        'getVeranstaltungsterminreiheUsingGET2' => [
            'application/json',
        ],
        'getVeranstaltungsterminreihenUsingGET' => [
            'application/json',
        ],
        'getVeranstaltungsterminreihenUsingGET1' => [
            'application/json',
        ],
    ];

/**
     * @param ClientInterface $client
     * @param Configuration   $config
     * @param HeaderSelector  $selector
     * @param int             $hostIndex (Optional) host index to select the list of hosts if defined in the OpenAPI spec
     */
    public function __construct(
        ClientInterface $client = null,
        Configuration $config = null,
        HeaderSelector $selector = null,
        $hostIndex = 0
    ) {
        $this->client = $client ?: new Client();
        $this->config = $config ?: new Configuration();
        $this->headerSelector = $selector ?: new HeaderSelector();
        $this->hostIndex = $hostIndex;
    }

    /**
     * Set the host index
     *
     * @param int $hostIndex Host index (required)
     */
    public function setHostIndex($hostIndex): void
    {
        $this->hostIndex = $hostIndex;
    }

    /**
     * Get the host index
     *
     * @return int Host index
     */
    public function getHostIndex()
    {
        return $this->hostIndex;
    }

    /**
     * @return Configuration
     */
    public function getConfig()
    {
        return $this->config;
    }

    /**
     * Operation getVeranstaltungsterminreiheUsingGET
     *
     * Ruft Veranstaltungsterminreihen ab (Websuche)
     *
     * @param  \OpenAPI\Client\Model\VeranstaltungsterminreihenSuche $verterminreihe_suche_api_dto verterminreiheSucheApiDto (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getVeranstaltungsterminreiheUsingGET'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\Veranstaltungsterminreihe[]
     */
    public function getVeranstaltungsterminreiheUsingGET($verterminreihe_suche_api_dto, string $contentType = self::contentTypes['getVeranstaltungsterminreiheUsingGET'][0])
    {
        list($response) = $this->getVeranstaltungsterminreiheUsingGETWithHttpInfo($verterminreihe_suche_api_dto, $contentType);
        return $response;
    }

    /**
     * Operation getVeranstaltungsterminreiheUsingGETWithHttpInfo
     *
     * Ruft Veranstaltungsterminreihen ab (Websuche)
     *
     * @param  \OpenAPI\Client\Model\VeranstaltungsterminreihenSuche $verterminreihe_suche_api_dto verterminreiheSucheApiDto (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getVeranstaltungsterminreiheUsingGET'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\Veranstaltungsterminreihe[], HTTP status code, HTTP response headers (array of strings)
     */
    public function getVeranstaltungsterminreiheUsingGETWithHttpInfo($verterminreihe_suche_api_dto, string $contentType = self::contentTypes['getVeranstaltungsterminreiheUsingGET'][0])
    {
        $request = $this->getVeranstaltungsterminreiheUsingGETRequest($verterminreihe_suche_api_dto, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\Veranstaltungsterminreihe[]' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\Veranstaltungsterminreihe[]' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\Veranstaltungsterminreihe[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\Veranstaltungsterminreihe[]';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\Veranstaltungsterminreihe[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getVeranstaltungsterminreiheUsingGETAsync
     *
     * Ruft Veranstaltungsterminreihen ab (Websuche)
     *
     * @param  \OpenAPI\Client\Model\VeranstaltungsterminreihenSuche $verterminreihe_suche_api_dto verterminreiheSucheApiDto (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getVeranstaltungsterminreiheUsingGET'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getVeranstaltungsterminreiheUsingGETAsync($verterminreihe_suche_api_dto, string $contentType = self::contentTypes['getVeranstaltungsterminreiheUsingGET'][0])
    {
        return $this->getVeranstaltungsterminreiheUsingGETAsyncWithHttpInfo($verterminreihe_suche_api_dto, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getVeranstaltungsterminreiheUsingGETAsyncWithHttpInfo
     *
     * Ruft Veranstaltungsterminreihen ab (Websuche)
     *
     * @param  \OpenAPI\Client\Model\VeranstaltungsterminreihenSuche $verterminreihe_suche_api_dto verterminreiheSucheApiDto (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getVeranstaltungsterminreiheUsingGET'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getVeranstaltungsterminreiheUsingGETAsyncWithHttpInfo($verterminreihe_suche_api_dto, string $contentType = self::contentTypes['getVeranstaltungsterminreiheUsingGET'][0])
    {
        $returnType = '\OpenAPI\Client\Model\Veranstaltungsterminreihe[]';
        $request = $this->getVeranstaltungsterminreiheUsingGETRequest($verterminreihe_suche_api_dto, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getVeranstaltungsterminreiheUsingGET'
     *
     * @param  \OpenAPI\Client\Model\VeranstaltungsterminreihenSuche $verterminreihe_suche_api_dto verterminreiheSucheApiDto (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getVeranstaltungsterminreiheUsingGET'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getVeranstaltungsterminreiheUsingGETRequest($verterminreihe_suche_api_dto, string $contentType = self::contentTypes['getVeranstaltungsterminreiheUsingGET'][0])
    {

        // verify the required parameter 'verterminreihe_suche_api_dto' is set
        if ($verterminreihe_suche_api_dto === null || (is_array($verterminreihe_suche_api_dto) && count($verterminreihe_suche_api_dto) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $verterminreihe_suche_api_dto when calling getVeranstaltungsterminreiheUsingGET'
            );
        }


        $resourcePath = '/v2/veranstaltungsterminreihen/websuche';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($verterminreihe_suche_api_dto)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($verterminreihe_suche_api_dto));
            } else {
                $httpBody = $verterminreihe_suche_api_dto;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getVeranstaltungsterminreiheUsingGET1
     *
     * Ruft eine Veranstaltungsterminreihe ab (entweder nicht storniert oder storniert)
     *
     * @param  string $id ID der Veranstaltungsterminreihe (required)
     * @param  bool $stornierte_veranstaltungsterminreihe_abrufen Optionaler Parameter, um zu steuern, ob eine stornierte oder eine nicht stornierte Veranstaltungsterminreihe abgerufen werden soll. Der Default ist false. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getVeranstaltungsterminreiheUsingGET1'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\Veranstaltungsterminreihe
     */
    public function getVeranstaltungsterminreiheUsingGET1($id, $stornierte_veranstaltungsterminreihe_abrufen = null, string $contentType = self::contentTypes['getVeranstaltungsterminreiheUsingGET1'][0])
    {
        list($response) = $this->getVeranstaltungsterminreiheUsingGET1WithHttpInfo($id, $stornierte_veranstaltungsterminreihe_abrufen, $contentType);
        return $response;
    }

    /**
     * Operation getVeranstaltungsterminreiheUsingGET1WithHttpInfo
     *
     * Ruft eine Veranstaltungsterminreihe ab (entweder nicht storniert oder storniert)
     *
     * @param  string $id ID der Veranstaltungsterminreihe (required)
     * @param  bool $stornierte_veranstaltungsterminreihe_abrufen Optionaler Parameter, um zu steuern, ob eine stornierte oder eine nicht stornierte Veranstaltungsterminreihe abgerufen werden soll. Der Default ist false. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getVeranstaltungsterminreiheUsingGET1'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\Veranstaltungsterminreihe, HTTP status code, HTTP response headers (array of strings)
     */
    public function getVeranstaltungsterminreiheUsingGET1WithHttpInfo($id, $stornierte_veranstaltungsterminreihe_abrufen = null, string $contentType = self::contentTypes['getVeranstaltungsterminreiheUsingGET1'][0])
    {
        $request = $this->getVeranstaltungsterminreiheUsingGET1Request($id, $stornierte_veranstaltungsterminreihe_abrufen, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\Veranstaltungsterminreihe' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\Veranstaltungsterminreihe' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\Veranstaltungsterminreihe', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\Veranstaltungsterminreihe';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\Veranstaltungsterminreihe',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getVeranstaltungsterminreiheUsingGET1Async
     *
     * Ruft eine Veranstaltungsterminreihe ab (entweder nicht storniert oder storniert)
     *
     * @param  string $id ID der Veranstaltungsterminreihe (required)
     * @param  bool $stornierte_veranstaltungsterminreihe_abrufen Optionaler Parameter, um zu steuern, ob eine stornierte oder eine nicht stornierte Veranstaltungsterminreihe abgerufen werden soll. Der Default ist false. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getVeranstaltungsterminreiheUsingGET1'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getVeranstaltungsterminreiheUsingGET1Async($id, $stornierte_veranstaltungsterminreihe_abrufen = null, string $contentType = self::contentTypes['getVeranstaltungsterminreiheUsingGET1'][0])
    {
        return $this->getVeranstaltungsterminreiheUsingGET1AsyncWithHttpInfo($id, $stornierte_veranstaltungsterminreihe_abrufen, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getVeranstaltungsterminreiheUsingGET1AsyncWithHttpInfo
     *
     * Ruft eine Veranstaltungsterminreihe ab (entweder nicht storniert oder storniert)
     *
     * @param  string $id ID der Veranstaltungsterminreihe (required)
     * @param  bool $stornierte_veranstaltungsterminreihe_abrufen Optionaler Parameter, um zu steuern, ob eine stornierte oder eine nicht stornierte Veranstaltungsterminreihe abgerufen werden soll. Der Default ist false. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getVeranstaltungsterminreiheUsingGET1'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getVeranstaltungsterminreiheUsingGET1AsyncWithHttpInfo($id, $stornierte_veranstaltungsterminreihe_abrufen = null, string $contentType = self::contentTypes['getVeranstaltungsterminreiheUsingGET1'][0])
    {
        $returnType = '\OpenAPI\Client\Model\Veranstaltungsterminreihe';
        $request = $this->getVeranstaltungsterminreiheUsingGET1Request($id, $stornierte_veranstaltungsterminreihe_abrufen, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getVeranstaltungsterminreiheUsingGET1'
     *
     * @param  string $id ID der Veranstaltungsterminreihe (required)
     * @param  bool $stornierte_veranstaltungsterminreihe_abrufen Optionaler Parameter, um zu steuern, ob eine stornierte oder eine nicht stornierte Veranstaltungsterminreihe abgerufen werden soll. Der Default ist false. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getVeranstaltungsterminreiheUsingGET1'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getVeranstaltungsterminreiheUsingGET1Request($id, $stornierte_veranstaltungsterminreihe_abrufen = null, string $contentType = self::contentTypes['getVeranstaltungsterminreiheUsingGET1'][0])
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling getVeranstaltungsterminreiheUsingGET1'
            );
        }



        $resourcePath = '/v2/veranstaltungsterminreihen/{id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $stornierte_veranstaltungsterminreihe_abrufen,
            'stornierteVeranstaltungsterminreiheAbrufen', // param base name
            'boolean', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);


        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getVeranstaltungsterminreiheUsingGET2
     *
     * Ruft eine Veranstaltungsterminreihe ab (entweder nicht storniert oder storniert)
     *
     * @param  string $id ID der Veranstaltungsterminreihe (required)
     * @param  bool $stornierte_veranstaltungsterminreihe_abrufen Optionaler Parameter, um zu steuern, ob eine stornierte oder eine nicht stornierte Veranstaltungsterminreihe abgerufen werden soll. Der Default ist false. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getVeranstaltungsterminreiheUsingGET2'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\VeranstaltungsterminreiheSIGUV
     */
    public function getVeranstaltungsterminreiheUsingGET2($id, $stornierte_veranstaltungsterminreihe_abrufen = null, string $contentType = self::contentTypes['getVeranstaltungsterminreiheUsingGET2'][0])
    {
        list($response) = $this->getVeranstaltungsterminreiheUsingGET2WithHttpInfo($id, $stornierte_veranstaltungsterminreihe_abrufen, $contentType);
        return $response;
    }

    /**
     * Operation getVeranstaltungsterminreiheUsingGET2WithHttpInfo
     *
     * Ruft eine Veranstaltungsterminreihe ab (entweder nicht storniert oder storniert)
     *
     * @param  string $id ID der Veranstaltungsterminreihe (required)
     * @param  bool $stornierte_veranstaltungsterminreihe_abrufen Optionaler Parameter, um zu steuern, ob eine stornierte oder eine nicht stornierte Veranstaltungsterminreihe abgerufen werden soll. Der Default ist false. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getVeranstaltungsterminreiheUsingGET2'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\VeranstaltungsterminreiheSIGUV, HTTP status code, HTTP response headers (array of strings)
     */
    public function getVeranstaltungsterminreiheUsingGET2WithHttpInfo($id, $stornierte_veranstaltungsterminreihe_abrufen = null, string $contentType = self::contentTypes['getVeranstaltungsterminreiheUsingGET2'][0])
    {
        $request = $this->getVeranstaltungsterminreiheUsingGET2Request($id, $stornierte_veranstaltungsterminreihe_abrufen, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\VeranstaltungsterminreiheSIGUV' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\VeranstaltungsterminreiheSIGUV' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\VeranstaltungsterminreiheSIGUV', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\VeranstaltungsterminreiheSIGUV';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\VeranstaltungsterminreiheSIGUV',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getVeranstaltungsterminreiheUsingGET2Async
     *
     * Ruft eine Veranstaltungsterminreihe ab (entweder nicht storniert oder storniert)
     *
     * @param  string $id ID der Veranstaltungsterminreihe (required)
     * @param  bool $stornierte_veranstaltungsterminreihe_abrufen Optionaler Parameter, um zu steuern, ob eine stornierte oder eine nicht stornierte Veranstaltungsterminreihe abgerufen werden soll. Der Default ist false. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getVeranstaltungsterminreiheUsingGET2'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getVeranstaltungsterminreiheUsingGET2Async($id, $stornierte_veranstaltungsterminreihe_abrufen = null, string $contentType = self::contentTypes['getVeranstaltungsterminreiheUsingGET2'][0])
    {
        return $this->getVeranstaltungsterminreiheUsingGET2AsyncWithHttpInfo($id, $stornierte_veranstaltungsterminreihe_abrufen, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getVeranstaltungsterminreiheUsingGET2AsyncWithHttpInfo
     *
     * Ruft eine Veranstaltungsterminreihe ab (entweder nicht storniert oder storniert)
     *
     * @param  string $id ID der Veranstaltungsterminreihe (required)
     * @param  bool $stornierte_veranstaltungsterminreihe_abrufen Optionaler Parameter, um zu steuern, ob eine stornierte oder eine nicht stornierte Veranstaltungsterminreihe abgerufen werden soll. Der Default ist false. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getVeranstaltungsterminreiheUsingGET2'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getVeranstaltungsterminreiheUsingGET2AsyncWithHttpInfo($id, $stornierte_veranstaltungsterminreihe_abrufen = null, string $contentType = self::contentTypes['getVeranstaltungsterminreiheUsingGET2'][0])
    {
        $returnType = '\OpenAPI\Client\Model\VeranstaltungsterminreiheSIGUV';
        $request = $this->getVeranstaltungsterminreiheUsingGET2Request($id, $stornierte_veranstaltungsterminreihe_abrufen, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getVeranstaltungsterminreiheUsingGET2'
     *
     * @param  string $id ID der Veranstaltungsterminreihe (required)
     * @param  bool $stornierte_veranstaltungsterminreihe_abrufen Optionaler Parameter, um zu steuern, ob eine stornierte oder eine nicht stornierte Veranstaltungsterminreihe abgerufen werden soll. Der Default ist false. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getVeranstaltungsterminreiheUsingGET2'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getVeranstaltungsterminreiheUsingGET2Request($id, $stornierte_veranstaltungsterminreihe_abrufen = null, string $contentType = self::contentTypes['getVeranstaltungsterminreiheUsingGET2'][0])
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling getVeranstaltungsterminreiheUsingGET2'
            );
        }



        $resourcePath = '/v2/20010/veranstaltungsterminreihen/{id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $stornierte_veranstaltungsterminreihe_abrufen,
            'stornierteVeranstaltungsterminreiheAbrufen', // param base name
            'boolean', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);


        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getVeranstaltungsterminreihenUsingGET
     *
     * Ruft Veranstaltungsterminreihen ab (entweder nicht stornierte oder stornierte)
     *
     * @param  \DateTime $modifiziert_ab Änderungs- bzw. Einfügezeitpunkt, ab dem die Veranstaltungsterminreihen geliefert werden sollen. Das Format muss wie folgt sein: yyyy-MM-ddTHH:mm:ss.SSS (optional)
     * @param  bool $stornierte_veranstaltungsterminreihen_abrufen Optionaler Parameter, um zu steuern, ob stornierte oder nicht stornierte Veranstaltungsterminreihen abgerufen werden sollen. Der Default ist false. (optional)
     * @param  string $veranstaltungstyp_id Optionaler Parameter, um nur Veranstaltungsterminreihen eines bestimmten Veranstaltungstyps abzurufen. Beispiel-ID: cfa1403a-13c6-4681-8ee3-e30127554845 (optional)
     * @param  string $teilnehmergruppekuerzel Optionaler Parameter, um zu steuern, für welche Teilnehmergruppe die Veranstaltungsterminreihen abgerufen werden sollen. Ist eine Teilnehmergruppe angegeben, so werden alle in der Zukunft liegenden und publizierten Veranstaltungsterminreihen für diese Teilnehmergruppe zurückgegeben. (optional)
     * @param  string $veranstaltungskategorie_id Optionaler Parameter, um Veranstaltungsterminreihen nach einer Veranstaltungskategorie zu filtern. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getVeranstaltungsterminreihenUsingGET'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\Veranstaltungsterminreihe[]
     */
    public function getVeranstaltungsterminreihenUsingGET($modifiziert_ab = null, $stornierte_veranstaltungsterminreihen_abrufen = null, $veranstaltungstyp_id = null, $teilnehmergruppekuerzel = null, $veranstaltungskategorie_id = null, string $contentType = self::contentTypes['getVeranstaltungsterminreihenUsingGET'][0])
    {
        list($response) = $this->getVeranstaltungsterminreihenUsingGETWithHttpInfo($modifiziert_ab, $stornierte_veranstaltungsterminreihen_abrufen, $veranstaltungstyp_id, $teilnehmergruppekuerzel, $veranstaltungskategorie_id, $contentType);
        return $response;
    }

    /**
     * Operation getVeranstaltungsterminreihenUsingGETWithHttpInfo
     *
     * Ruft Veranstaltungsterminreihen ab (entweder nicht stornierte oder stornierte)
     *
     * @param  \DateTime $modifiziert_ab Änderungs- bzw. Einfügezeitpunkt, ab dem die Veranstaltungsterminreihen geliefert werden sollen. Das Format muss wie folgt sein: yyyy-MM-ddTHH:mm:ss.SSS (optional)
     * @param  bool $stornierte_veranstaltungsterminreihen_abrufen Optionaler Parameter, um zu steuern, ob stornierte oder nicht stornierte Veranstaltungsterminreihen abgerufen werden sollen. Der Default ist false. (optional)
     * @param  string $veranstaltungstyp_id Optionaler Parameter, um nur Veranstaltungsterminreihen eines bestimmten Veranstaltungstyps abzurufen. Beispiel-ID: cfa1403a-13c6-4681-8ee3-e30127554845 (optional)
     * @param  string $teilnehmergruppekuerzel Optionaler Parameter, um zu steuern, für welche Teilnehmergruppe die Veranstaltungsterminreihen abgerufen werden sollen. Ist eine Teilnehmergruppe angegeben, so werden alle in der Zukunft liegenden und publizierten Veranstaltungsterminreihen für diese Teilnehmergruppe zurückgegeben. (optional)
     * @param  string $veranstaltungskategorie_id Optionaler Parameter, um Veranstaltungsterminreihen nach einer Veranstaltungskategorie zu filtern. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getVeranstaltungsterminreihenUsingGET'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\Veranstaltungsterminreihe[], HTTP status code, HTTP response headers (array of strings)
     */
    public function getVeranstaltungsterminreihenUsingGETWithHttpInfo($modifiziert_ab = null, $stornierte_veranstaltungsterminreihen_abrufen = null, $veranstaltungstyp_id = null, $teilnehmergruppekuerzel = null, $veranstaltungskategorie_id = null, string $contentType = self::contentTypes['getVeranstaltungsterminreihenUsingGET'][0])
    {
        $request = $this->getVeranstaltungsterminreihenUsingGETRequest($modifiziert_ab, $stornierte_veranstaltungsterminreihen_abrufen, $veranstaltungstyp_id, $teilnehmergruppekuerzel, $veranstaltungskategorie_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\Veranstaltungsterminreihe[]' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\Veranstaltungsterminreihe[]' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\Veranstaltungsterminreihe[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\Veranstaltungsterminreihe[]';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\Veranstaltungsterminreihe[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getVeranstaltungsterminreihenUsingGETAsync
     *
     * Ruft Veranstaltungsterminreihen ab (entweder nicht stornierte oder stornierte)
     *
     * @param  \DateTime $modifiziert_ab Änderungs- bzw. Einfügezeitpunkt, ab dem die Veranstaltungsterminreihen geliefert werden sollen. Das Format muss wie folgt sein: yyyy-MM-ddTHH:mm:ss.SSS (optional)
     * @param  bool $stornierte_veranstaltungsterminreihen_abrufen Optionaler Parameter, um zu steuern, ob stornierte oder nicht stornierte Veranstaltungsterminreihen abgerufen werden sollen. Der Default ist false. (optional)
     * @param  string $veranstaltungstyp_id Optionaler Parameter, um nur Veranstaltungsterminreihen eines bestimmten Veranstaltungstyps abzurufen. Beispiel-ID: cfa1403a-13c6-4681-8ee3-e30127554845 (optional)
     * @param  string $teilnehmergruppekuerzel Optionaler Parameter, um zu steuern, für welche Teilnehmergruppe die Veranstaltungsterminreihen abgerufen werden sollen. Ist eine Teilnehmergruppe angegeben, so werden alle in der Zukunft liegenden und publizierten Veranstaltungsterminreihen für diese Teilnehmergruppe zurückgegeben. (optional)
     * @param  string $veranstaltungskategorie_id Optionaler Parameter, um Veranstaltungsterminreihen nach einer Veranstaltungskategorie zu filtern. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getVeranstaltungsterminreihenUsingGET'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getVeranstaltungsterminreihenUsingGETAsync($modifiziert_ab = null, $stornierte_veranstaltungsterminreihen_abrufen = null, $veranstaltungstyp_id = null, $teilnehmergruppekuerzel = null, $veranstaltungskategorie_id = null, string $contentType = self::contentTypes['getVeranstaltungsterminreihenUsingGET'][0])
    {
        return $this->getVeranstaltungsterminreihenUsingGETAsyncWithHttpInfo($modifiziert_ab, $stornierte_veranstaltungsterminreihen_abrufen, $veranstaltungstyp_id, $teilnehmergruppekuerzel, $veranstaltungskategorie_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getVeranstaltungsterminreihenUsingGETAsyncWithHttpInfo
     *
     * Ruft Veranstaltungsterminreihen ab (entweder nicht stornierte oder stornierte)
     *
     * @param  \DateTime $modifiziert_ab Änderungs- bzw. Einfügezeitpunkt, ab dem die Veranstaltungsterminreihen geliefert werden sollen. Das Format muss wie folgt sein: yyyy-MM-ddTHH:mm:ss.SSS (optional)
     * @param  bool $stornierte_veranstaltungsterminreihen_abrufen Optionaler Parameter, um zu steuern, ob stornierte oder nicht stornierte Veranstaltungsterminreihen abgerufen werden sollen. Der Default ist false. (optional)
     * @param  string $veranstaltungstyp_id Optionaler Parameter, um nur Veranstaltungsterminreihen eines bestimmten Veranstaltungstyps abzurufen. Beispiel-ID: cfa1403a-13c6-4681-8ee3-e30127554845 (optional)
     * @param  string $teilnehmergruppekuerzel Optionaler Parameter, um zu steuern, für welche Teilnehmergruppe die Veranstaltungsterminreihen abgerufen werden sollen. Ist eine Teilnehmergruppe angegeben, so werden alle in der Zukunft liegenden und publizierten Veranstaltungsterminreihen für diese Teilnehmergruppe zurückgegeben. (optional)
     * @param  string $veranstaltungskategorie_id Optionaler Parameter, um Veranstaltungsterminreihen nach einer Veranstaltungskategorie zu filtern. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getVeranstaltungsterminreihenUsingGET'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getVeranstaltungsterminreihenUsingGETAsyncWithHttpInfo($modifiziert_ab = null, $stornierte_veranstaltungsterminreihen_abrufen = null, $veranstaltungstyp_id = null, $teilnehmergruppekuerzel = null, $veranstaltungskategorie_id = null, string $contentType = self::contentTypes['getVeranstaltungsterminreihenUsingGET'][0])
    {
        $returnType = '\OpenAPI\Client\Model\Veranstaltungsterminreihe[]';
        $request = $this->getVeranstaltungsterminreihenUsingGETRequest($modifiziert_ab, $stornierte_veranstaltungsterminreihen_abrufen, $veranstaltungstyp_id, $teilnehmergruppekuerzel, $veranstaltungskategorie_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getVeranstaltungsterminreihenUsingGET'
     *
     * @param  \DateTime $modifiziert_ab Änderungs- bzw. Einfügezeitpunkt, ab dem die Veranstaltungsterminreihen geliefert werden sollen. Das Format muss wie folgt sein: yyyy-MM-ddTHH:mm:ss.SSS (optional)
     * @param  bool $stornierte_veranstaltungsterminreihen_abrufen Optionaler Parameter, um zu steuern, ob stornierte oder nicht stornierte Veranstaltungsterminreihen abgerufen werden sollen. Der Default ist false. (optional)
     * @param  string $veranstaltungstyp_id Optionaler Parameter, um nur Veranstaltungsterminreihen eines bestimmten Veranstaltungstyps abzurufen. Beispiel-ID: cfa1403a-13c6-4681-8ee3-e30127554845 (optional)
     * @param  string $teilnehmergruppekuerzel Optionaler Parameter, um zu steuern, für welche Teilnehmergruppe die Veranstaltungsterminreihen abgerufen werden sollen. Ist eine Teilnehmergruppe angegeben, so werden alle in der Zukunft liegenden und publizierten Veranstaltungsterminreihen für diese Teilnehmergruppe zurückgegeben. (optional)
     * @param  string $veranstaltungskategorie_id Optionaler Parameter, um Veranstaltungsterminreihen nach einer Veranstaltungskategorie zu filtern. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getVeranstaltungsterminreihenUsingGET'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getVeranstaltungsterminreihenUsingGETRequest($modifiziert_ab = null, $stornierte_veranstaltungsterminreihen_abrufen = null, $veranstaltungstyp_id = null, $teilnehmergruppekuerzel = null, $veranstaltungskategorie_id = null, string $contentType = self::contentTypes['getVeranstaltungsterminreihenUsingGET'][0])
    {







        $resourcePath = '/v2/veranstaltungsterminreihen';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $modifiziert_ab,
            'modifiziertAb', // param base name
            'string', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $stornierte_veranstaltungsterminreihen_abrufen,
            'stornierteVeranstaltungsterminreihenAbrufen', // param base name
            'boolean', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $veranstaltungstyp_id,
            'veranstaltungstypID', // param base name
            'string', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $teilnehmergruppekuerzel,
            'teilnehmergruppekuerzel', // param base name
            'string', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $veranstaltungskategorie_id,
            'veranstaltungskategorieId', // param base name
            'string', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);




        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getVeranstaltungsterminreihenUsingGET1
     *
     * Ruft Veranstaltungsterminreihen ab (entweder nicht stornierte oder stornierte)
     *
     * @param  \DateTime $modifiziert_ab Änderungs- bzw. Einfügezeitpunkt, ab dem die Veranstaltungsterminreihen geliefert werden sollen. Das Format muss wie folgt sein: yyyy-MM-ddTHH:mm:ss.SSS (optional)
     * @param  bool $stornierte_veranstaltungsterminreihen_abrufen Optionaler Parameter, um zu steuern, ob stornierte oder nicht stornierte Veranstaltungsterminreihen abgerufen werden sollen. Der Default ist false. (optional)
     * @param  string $veranstaltungstyp_id Optionaler Parameter, um nur Veranstaltungsterminreihen eines bestimmten Veranstaltungstyps abzurufen. Beispiel-ID: cfa1403a-13c6-4681-8ee3-e30127554845 (optional)
     * @param  string $teilnehmergruppekuerzel Optionaler Parameter, um zu steuern, für welche Teilnehmergruppe die Veranstaltungsterminreihen abgerufen werden sollen. Ist eine Teilnehmergruppe angegeben, so werden alle in der Zukunft liegenden und publizierten Veranstaltungsterminreihen für diese Teilnehmergruppe zurückgegeben. (optional)
     * @param  string $veranstaltungskategorie_id Optionaler Parameter, um Veranstaltungsterminreihen nach einer Veranstaltungskategorie zu filtern. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getVeranstaltungsterminreihenUsingGET1'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\VeranstaltungsterminreiheSIGUV[]
     */
    public function getVeranstaltungsterminreihenUsingGET1($modifiziert_ab = null, $stornierte_veranstaltungsterminreihen_abrufen = null, $veranstaltungstyp_id = null, $teilnehmergruppekuerzel = null, $veranstaltungskategorie_id = null, string $contentType = self::contentTypes['getVeranstaltungsterminreihenUsingGET1'][0])
    {
        list($response) = $this->getVeranstaltungsterminreihenUsingGET1WithHttpInfo($modifiziert_ab, $stornierte_veranstaltungsterminreihen_abrufen, $veranstaltungstyp_id, $teilnehmergruppekuerzel, $veranstaltungskategorie_id, $contentType);
        return $response;
    }

    /**
     * Operation getVeranstaltungsterminreihenUsingGET1WithHttpInfo
     *
     * Ruft Veranstaltungsterminreihen ab (entweder nicht stornierte oder stornierte)
     *
     * @param  \DateTime $modifiziert_ab Änderungs- bzw. Einfügezeitpunkt, ab dem die Veranstaltungsterminreihen geliefert werden sollen. Das Format muss wie folgt sein: yyyy-MM-ddTHH:mm:ss.SSS (optional)
     * @param  bool $stornierte_veranstaltungsterminreihen_abrufen Optionaler Parameter, um zu steuern, ob stornierte oder nicht stornierte Veranstaltungsterminreihen abgerufen werden sollen. Der Default ist false. (optional)
     * @param  string $veranstaltungstyp_id Optionaler Parameter, um nur Veranstaltungsterminreihen eines bestimmten Veranstaltungstyps abzurufen. Beispiel-ID: cfa1403a-13c6-4681-8ee3-e30127554845 (optional)
     * @param  string $teilnehmergruppekuerzel Optionaler Parameter, um zu steuern, für welche Teilnehmergruppe die Veranstaltungsterminreihen abgerufen werden sollen. Ist eine Teilnehmergruppe angegeben, so werden alle in der Zukunft liegenden und publizierten Veranstaltungsterminreihen für diese Teilnehmergruppe zurückgegeben. (optional)
     * @param  string $veranstaltungskategorie_id Optionaler Parameter, um Veranstaltungsterminreihen nach einer Veranstaltungskategorie zu filtern. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getVeranstaltungsterminreihenUsingGET1'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\VeranstaltungsterminreiheSIGUV[], HTTP status code, HTTP response headers (array of strings)
     */
    public function getVeranstaltungsterminreihenUsingGET1WithHttpInfo($modifiziert_ab = null, $stornierte_veranstaltungsterminreihen_abrufen = null, $veranstaltungstyp_id = null, $teilnehmergruppekuerzel = null, $veranstaltungskategorie_id = null, string $contentType = self::contentTypes['getVeranstaltungsterminreihenUsingGET1'][0])
    {
        $request = $this->getVeranstaltungsterminreihenUsingGET1Request($modifiziert_ab, $stornierte_veranstaltungsterminreihen_abrufen, $veranstaltungstyp_id, $teilnehmergruppekuerzel, $veranstaltungskategorie_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\VeranstaltungsterminreiheSIGUV[]' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\VeranstaltungsterminreiheSIGUV[]' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\VeranstaltungsterminreiheSIGUV[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\VeranstaltungsterminreiheSIGUV[]';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\VeranstaltungsterminreiheSIGUV[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getVeranstaltungsterminreihenUsingGET1Async
     *
     * Ruft Veranstaltungsterminreihen ab (entweder nicht stornierte oder stornierte)
     *
     * @param  \DateTime $modifiziert_ab Änderungs- bzw. Einfügezeitpunkt, ab dem die Veranstaltungsterminreihen geliefert werden sollen. Das Format muss wie folgt sein: yyyy-MM-ddTHH:mm:ss.SSS (optional)
     * @param  bool $stornierte_veranstaltungsterminreihen_abrufen Optionaler Parameter, um zu steuern, ob stornierte oder nicht stornierte Veranstaltungsterminreihen abgerufen werden sollen. Der Default ist false. (optional)
     * @param  string $veranstaltungstyp_id Optionaler Parameter, um nur Veranstaltungsterminreihen eines bestimmten Veranstaltungstyps abzurufen. Beispiel-ID: cfa1403a-13c6-4681-8ee3-e30127554845 (optional)
     * @param  string $teilnehmergruppekuerzel Optionaler Parameter, um zu steuern, für welche Teilnehmergruppe die Veranstaltungsterminreihen abgerufen werden sollen. Ist eine Teilnehmergruppe angegeben, so werden alle in der Zukunft liegenden und publizierten Veranstaltungsterminreihen für diese Teilnehmergruppe zurückgegeben. (optional)
     * @param  string $veranstaltungskategorie_id Optionaler Parameter, um Veranstaltungsterminreihen nach einer Veranstaltungskategorie zu filtern. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getVeranstaltungsterminreihenUsingGET1'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getVeranstaltungsterminreihenUsingGET1Async($modifiziert_ab = null, $stornierte_veranstaltungsterminreihen_abrufen = null, $veranstaltungstyp_id = null, $teilnehmergruppekuerzel = null, $veranstaltungskategorie_id = null, string $contentType = self::contentTypes['getVeranstaltungsterminreihenUsingGET1'][0])
    {
        return $this->getVeranstaltungsterminreihenUsingGET1AsyncWithHttpInfo($modifiziert_ab, $stornierte_veranstaltungsterminreihen_abrufen, $veranstaltungstyp_id, $teilnehmergruppekuerzel, $veranstaltungskategorie_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getVeranstaltungsterminreihenUsingGET1AsyncWithHttpInfo
     *
     * Ruft Veranstaltungsterminreihen ab (entweder nicht stornierte oder stornierte)
     *
     * @param  \DateTime $modifiziert_ab Änderungs- bzw. Einfügezeitpunkt, ab dem die Veranstaltungsterminreihen geliefert werden sollen. Das Format muss wie folgt sein: yyyy-MM-ddTHH:mm:ss.SSS (optional)
     * @param  bool $stornierte_veranstaltungsterminreihen_abrufen Optionaler Parameter, um zu steuern, ob stornierte oder nicht stornierte Veranstaltungsterminreihen abgerufen werden sollen. Der Default ist false. (optional)
     * @param  string $veranstaltungstyp_id Optionaler Parameter, um nur Veranstaltungsterminreihen eines bestimmten Veranstaltungstyps abzurufen. Beispiel-ID: cfa1403a-13c6-4681-8ee3-e30127554845 (optional)
     * @param  string $teilnehmergruppekuerzel Optionaler Parameter, um zu steuern, für welche Teilnehmergruppe die Veranstaltungsterminreihen abgerufen werden sollen. Ist eine Teilnehmergruppe angegeben, so werden alle in der Zukunft liegenden und publizierten Veranstaltungsterminreihen für diese Teilnehmergruppe zurückgegeben. (optional)
     * @param  string $veranstaltungskategorie_id Optionaler Parameter, um Veranstaltungsterminreihen nach einer Veranstaltungskategorie zu filtern. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getVeranstaltungsterminreihenUsingGET1'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getVeranstaltungsterminreihenUsingGET1AsyncWithHttpInfo($modifiziert_ab = null, $stornierte_veranstaltungsterminreihen_abrufen = null, $veranstaltungstyp_id = null, $teilnehmergruppekuerzel = null, $veranstaltungskategorie_id = null, string $contentType = self::contentTypes['getVeranstaltungsterminreihenUsingGET1'][0])
    {
        $returnType = '\OpenAPI\Client\Model\VeranstaltungsterminreiheSIGUV[]';
        $request = $this->getVeranstaltungsterminreihenUsingGET1Request($modifiziert_ab, $stornierte_veranstaltungsterminreihen_abrufen, $veranstaltungstyp_id, $teilnehmergruppekuerzel, $veranstaltungskategorie_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getVeranstaltungsterminreihenUsingGET1'
     *
     * @param  \DateTime $modifiziert_ab Änderungs- bzw. Einfügezeitpunkt, ab dem die Veranstaltungsterminreihen geliefert werden sollen. Das Format muss wie folgt sein: yyyy-MM-ddTHH:mm:ss.SSS (optional)
     * @param  bool $stornierte_veranstaltungsterminreihen_abrufen Optionaler Parameter, um zu steuern, ob stornierte oder nicht stornierte Veranstaltungsterminreihen abgerufen werden sollen. Der Default ist false. (optional)
     * @param  string $veranstaltungstyp_id Optionaler Parameter, um nur Veranstaltungsterminreihen eines bestimmten Veranstaltungstyps abzurufen. Beispiel-ID: cfa1403a-13c6-4681-8ee3-e30127554845 (optional)
     * @param  string $teilnehmergruppekuerzel Optionaler Parameter, um zu steuern, für welche Teilnehmergruppe die Veranstaltungsterminreihen abgerufen werden sollen. Ist eine Teilnehmergruppe angegeben, so werden alle in der Zukunft liegenden und publizierten Veranstaltungsterminreihen für diese Teilnehmergruppe zurückgegeben. (optional)
     * @param  string $veranstaltungskategorie_id Optionaler Parameter, um Veranstaltungsterminreihen nach einer Veranstaltungskategorie zu filtern. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getVeranstaltungsterminreihenUsingGET1'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getVeranstaltungsterminreihenUsingGET1Request($modifiziert_ab = null, $stornierte_veranstaltungsterminreihen_abrufen = null, $veranstaltungstyp_id = null, $teilnehmergruppekuerzel = null, $veranstaltungskategorie_id = null, string $contentType = self::contentTypes['getVeranstaltungsterminreihenUsingGET1'][0])
    {







        $resourcePath = '/v2/20010/veranstaltungsterminreihen';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $modifiziert_ab,
            'modifiziertAb', // param base name
            'string', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $stornierte_veranstaltungsterminreihen_abrufen,
            'stornierteVeranstaltungsterminreihenAbrufen', // param base name
            'boolean', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $veranstaltungstyp_id,
            'veranstaltungstypID', // param base name
            'string', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $teilnehmergruppekuerzel,
            'teilnehmergruppekuerzel', // param base name
            'string', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $veranstaltungskategorie_id,
            'veranstaltungskategorieId', // param base name
            'string', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);




        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Create http client option
     *
     * @throws \RuntimeException on file opening failure
     * @return array of http client options
     */
    protected function createHttpClientOption()
    {
        $options = [];
        if ($this->config->getDebug()) {
            $options[RequestOptions::DEBUG] = fopen($this->config->getDebugFile(), 'a');
            if (!$options[RequestOptions::DEBUG]) {
                throw new \RuntimeException('Failed to open the debug file: ' . $this->config->getDebugFile());
            }
        }

        return $options;
    }
}
