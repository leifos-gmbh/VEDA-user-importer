<?php
/**
 * VeranstaltungstermineApi
 * PHP version 7.4
 *
 * @category Class
 * @package  OpenAPI\Client
 * @author   OpenAPI Generator team
 * @link     https://openapi-generator.tech
 */

/**
 * VEDA Bildungsmanager API
 *
 * Dokumentation der REST-Schnittstellen des VEDA Bildungsmanagers für die Version 2. Die Dokumentation zu speziellen Versionen kann über die Angabe des zusätzlichen Parameters \"group\" angezeigt werden. Beispiel: .../api/docs?group=v1 für die Dokumentation der Version 1, die aktuelle Version ist unter .../api/docs erreichbar.
 *
 * The version of the OpenAPI document: 2
 * Contact: info@veda.net
 * Generated by: https://openapi-generator.tech
 * OpenAPI Generator version: 6.6.0
 */

/**
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

namespace OpenAPI\Client\Api;

use GuzzleHttp\Client;
use GuzzleHttp\ClientInterface;
use GuzzleHttp\Exception\ConnectException;
use GuzzleHttp\Exception\RequestException;
use GuzzleHttp\Psr7\MultipartStream;
use GuzzleHttp\Psr7\Request;
use GuzzleHttp\RequestOptions;
use OpenAPI\Client\ApiException;
use OpenAPI\Client\Configuration;
use OpenAPI\Client\HeaderSelector;
use OpenAPI\Client\ObjectSerializer;

/**
 * VeranstaltungstermineApi Class Doc Comment
 *
 * @category Class
 * @package  OpenAPI\Client
 * @author   OpenAPI Generator team
 * @link     https://openapi-generator.tech
 */
class VeranstaltungstermineApi
{
    /**
     * @var ClientInterface
     */
    protected $client;

    /**
     * @var Configuration
     */
    protected $config;

    /**
     * @var HeaderSelector
     */
    protected $headerSelector;

    /**
     * @var int Host index
     */
    protected $hostIndex;

    /** @var string[] $contentTypes **/
    public const contentTypes = [
        'createVeranstaltungsterminBuchungUsingPOST' => [
            'application/json',
        ],
        'createVeranstaltungsterminBuchungUsingPOST1' => [
            'application/json',
        ],
        'getTeilnehmerbuchungenZuVeranstaltungsterminUsingGET' => [
            'application/json',
        ],
        'getTeilnehmerbuchungenZuVeranstaltungsterminUsingGET1' => [
            'application/json',
        ],
        'getVeranstaltungsterminUsingGET' => [
            'application/json',
        ],
        'getVeranstaltungsterminUsingGET1' => [
            'application/json',
        ],
        'getVeranstaltungstermineUsingGET' => [
            'application/json',
        ],
        'getVeranstaltungstermineUsingGET1' => [
            'application/json',
        ],
        'getVeranstaltungstermineUsingGET2' => [
            'application/json',
        ],
        'getVeranstaltungstermineUsingGET3' => [
            'application/json',
        ],
        'getVeranstaltungstypPlzBereicheUsingGET' => [
            'application/json',
        ],
    ];

/**
     * @param ClientInterface $client
     * @param Configuration   $config
     * @param HeaderSelector  $selector
     * @param int             $hostIndex (Optional) host index to select the list of hosts if defined in the OpenAPI spec
     */
    public function __construct(
        ClientInterface $client = null,
        Configuration $config = null,
        HeaderSelector $selector = null,
        $hostIndex = 0
    ) {
        $this->client = $client ?: new Client();
        $this->config = $config ?: new Configuration();
        $this->headerSelector = $selector ?: new HeaderSelector();
        $this->hostIndex = $hostIndex;
    }

    /**
     * Set the host index
     *
     * @param int $hostIndex Host index (required)
     */
    public function setHostIndex($hostIndex): void
    {
        $this->hostIndex = $hostIndex;
    }

    /**
     * Get the host index
     *
     * @return int Host index
     */
    public function getHostIndex()
    {
        return $this->hostIndex;
    }

    /**
     * @return Configuration
     */
    public function getConfig()
    {
        return $this->config;
    }

    /**
     * Operation createVeranstaltungsterminBuchungUsingPOST
     *
     * Ermöglicht es, einen Teilnehmer auf einen Veranstaltungstermin zu buchen.
     *
     * @param  string $termin_id ID des Veranstaltungstermins (required)
     * @param  \OpenAPI\Client\Model\TeilnehmerAktionBuchenApiDto $teilnehmer_aktion_buchen_api_dto Informationen zu einer Teilnehmerbuchung, die angelegt werden soll. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createVeranstaltungsterminBuchungUsingPOST'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\TeilnehmerbuchungApiDto
     */
    public function createVeranstaltungsterminBuchungUsingPOST($termin_id, $teilnehmer_aktion_buchen_api_dto = null, string $contentType = self::contentTypes['createVeranstaltungsterminBuchungUsingPOST'][0])
    {
        list($response) = $this->createVeranstaltungsterminBuchungUsingPOSTWithHttpInfo($termin_id, $teilnehmer_aktion_buchen_api_dto, $contentType);
        return $response;
    }

    /**
     * Operation createVeranstaltungsterminBuchungUsingPOSTWithHttpInfo
     *
     * Ermöglicht es, einen Teilnehmer auf einen Veranstaltungstermin zu buchen.
     *
     * @param  string $termin_id ID des Veranstaltungstermins (required)
     * @param  \OpenAPI\Client\Model\TeilnehmerAktionBuchenApiDto $teilnehmer_aktion_buchen_api_dto Informationen zu einer Teilnehmerbuchung, die angelegt werden soll. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createVeranstaltungsterminBuchungUsingPOST'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\TeilnehmerbuchungApiDto, HTTP status code, HTTP response headers (array of strings)
     */
    public function createVeranstaltungsterminBuchungUsingPOSTWithHttpInfo($termin_id, $teilnehmer_aktion_buchen_api_dto = null, string $contentType = self::contentTypes['createVeranstaltungsterminBuchungUsingPOST'][0])
    {
        $request = $this->createVeranstaltungsterminBuchungUsingPOSTRequest($termin_id, $teilnehmer_aktion_buchen_api_dto, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\TeilnehmerbuchungApiDto' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\TeilnehmerbuchungApiDto' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\TeilnehmerbuchungApiDto', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\TeilnehmerbuchungApiDto';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\TeilnehmerbuchungApiDto',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation createVeranstaltungsterminBuchungUsingPOSTAsync
     *
     * Ermöglicht es, einen Teilnehmer auf einen Veranstaltungstermin zu buchen.
     *
     * @param  string $termin_id ID des Veranstaltungstermins (required)
     * @param  \OpenAPI\Client\Model\TeilnehmerAktionBuchenApiDto $teilnehmer_aktion_buchen_api_dto Informationen zu einer Teilnehmerbuchung, die angelegt werden soll. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createVeranstaltungsterminBuchungUsingPOST'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createVeranstaltungsterminBuchungUsingPOSTAsync($termin_id, $teilnehmer_aktion_buchen_api_dto = null, string $contentType = self::contentTypes['createVeranstaltungsterminBuchungUsingPOST'][0])
    {
        return $this->createVeranstaltungsterminBuchungUsingPOSTAsyncWithHttpInfo($termin_id, $teilnehmer_aktion_buchen_api_dto, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation createVeranstaltungsterminBuchungUsingPOSTAsyncWithHttpInfo
     *
     * Ermöglicht es, einen Teilnehmer auf einen Veranstaltungstermin zu buchen.
     *
     * @param  string $termin_id ID des Veranstaltungstermins (required)
     * @param  \OpenAPI\Client\Model\TeilnehmerAktionBuchenApiDto $teilnehmer_aktion_buchen_api_dto Informationen zu einer Teilnehmerbuchung, die angelegt werden soll. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createVeranstaltungsterminBuchungUsingPOST'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createVeranstaltungsterminBuchungUsingPOSTAsyncWithHttpInfo($termin_id, $teilnehmer_aktion_buchen_api_dto = null, string $contentType = self::contentTypes['createVeranstaltungsterminBuchungUsingPOST'][0])
    {
        $returnType = '\OpenAPI\Client\Model\TeilnehmerbuchungApiDto';
        $request = $this->createVeranstaltungsterminBuchungUsingPOSTRequest($termin_id, $teilnehmer_aktion_buchen_api_dto, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'createVeranstaltungsterminBuchungUsingPOST'
     *
     * @param  string $termin_id ID des Veranstaltungstermins (required)
     * @param  \OpenAPI\Client\Model\TeilnehmerAktionBuchenApiDto $teilnehmer_aktion_buchen_api_dto Informationen zu einer Teilnehmerbuchung, die angelegt werden soll. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createVeranstaltungsterminBuchungUsingPOST'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function createVeranstaltungsterminBuchungUsingPOSTRequest($termin_id, $teilnehmer_aktion_buchen_api_dto = null, string $contentType = self::contentTypes['createVeranstaltungsterminBuchungUsingPOST'][0])
    {

        // verify the required parameter 'termin_id' is set
        if ($termin_id === null || (is_array($termin_id) && count($termin_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $termin_id when calling createVeranstaltungsterminBuchungUsingPOST'
            );
        }



        $resourcePath = '/v2/veranstaltungstermine/{terminId}/buchen';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($termin_id !== null) {
            $resourcePath = str_replace(
                '{' . 'terminId' . '}',
                ObjectSerializer::toPathValue($termin_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($teilnehmer_aktion_buchen_api_dto)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($teilnehmer_aktion_buchen_api_dto));
            } else {
                $httpBody = $teilnehmer_aktion_buchen_api_dto;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation createVeranstaltungsterminBuchungUsingPOST1
     *
     * Ermöglicht es, einen Teilnehmer auf einen Veranstaltungstermin zu buchen.
     *
     * @param  string $termin_id ID des Veranstaltungstermins (required)
     * @param  \OpenAPI\Client\Model\TeilnehmerAktionBuchenApiDto $teilnehmer_aktion_buchen_api_dto Informationen zu einer Teilnehmerbuchung, die angelegt werden soll. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createVeranstaltungsterminBuchungUsingPOST1'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\TeilnehmerbuchungApiDto
     */
    public function createVeranstaltungsterminBuchungUsingPOST1($termin_id, $teilnehmer_aktion_buchen_api_dto = null, string $contentType = self::contentTypes['createVeranstaltungsterminBuchungUsingPOST1'][0])
    {
        list($response) = $this->createVeranstaltungsterminBuchungUsingPOST1WithHttpInfo($termin_id, $teilnehmer_aktion_buchen_api_dto, $contentType);
        return $response;
    }

    /**
     * Operation createVeranstaltungsterminBuchungUsingPOST1WithHttpInfo
     *
     * Ermöglicht es, einen Teilnehmer auf einen Veranstaltungstermin zu buchen.
     *
     * @param  string $termin_id ID des Veranstaltungstermins (required)
     * @param  \OpenAPI\Client\Model\TeilnehmerAktionBuchenApiDto $teilnehmer_aktion_buchen_api_dto Informationen zu einer Teilnehmerbuchung, die angelegt werden soll. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createVeranstaltungsterminBuchungUsingPOST1'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\TeilnehmerbuchungApiDto, HTTP status code, HTTP response headers (array of strings)
     */
    public function createVeranstaltungsterminBuchungUsingPOST1WithHttpInfo($termin_id, $teilnehmer_aktion_buchen_api_dto = null, string $contentType = self::contentTypes['createVeranstaltungsterminBuchungUsingPOST1'][0])
    {
        $request = $this->createVeranstaltungsterminBuchungUsingPOST1Request($termin_id, $teilnehmer_aktion_buchen_api_dto, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\TeilnehmerbuchungApiDto' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\TeilnehmerbuchungApiDto' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\TeilnehmerbuchungApiDto', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\TeilnehmerbuchungApiDto';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\TeilnehmerbuchungApiDto',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation createVeranstaltungsterminBuchungUsingPOST1Async
     *
     * Ermöglicht es, einen Teilnehmer auf einen Veranstaltungstermin zu buchen.
     *
     * @param  string $termin_id ID des Veranstaltungstermins (required)
     * @param  \OpenAPI\Client\Model\TeilnehmerAktionBuchenApiDto $teilnehmer_aktion_buchen_api_dto Informationen zu einer Teilnehmerbuchung, die angelegt werden soll. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createVeranstaltungsterminBuchungUsingPOST1'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createVeranstaltungsterminBuchungUsingPOST1Async($termin_id, $teilnehmer_aktion_buchen_api_dto = null, string $contentType = self::contentTypes['createVeranstaltungsterminBuchungUsingPOST1'][0])
    {
        return $this->createVeranstaltungsterminBuchungUsingPOST1AsyncWithHttpInfo($termin_id, $teilnehmer_aktion_buchen_api_dto, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation createVeranstaltungsterminBuchungUsingPOST1AsyncWithHttpInfo
     *
     * Ermöglicht es, einen Teilnehmer auf einen Veranstaltungstermin zu buchen.
     *
     * @param  string $termin_id ID des Veranstaltungstermins (required)
     * @param  \OpenAPI\Client\Model\TeilnehmerAktionBuchenApiDto $teilnehmer_aktion_buchen_api_dto Informationen zu einer Teilnehmerbuchung, die angelegt werden soll. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createVeranstaltungsterminBuchungUsingPOST1'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createVeranstaltungsterminBuchungUsingPOST1AsyncWithHttpInfo($termin_id, $teilnehmer_aktion_buchen_api_dto = null, string $contentType = self::contentTypes['createVeranstaltungsterminBuchungUsingPOST1'][0])
    {
        $returnType = '\OpenAPI\Client\Model\TeilnehmerbuchungApiDto';
        $request = $this->createVeranstaltungsterminBuchungUsingPOST1Request($termin_id, $teilnehmer_aktion_buchen_api_dto, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'createVeranstaltungsterminBuchungUsingPOST1'
     *
     * @param  string $termin_id ID des Veranstaltungstermins (required)
     * @param  \OpenAPI\Client\Model\TeilnehmerAktionBuchenApiDto $teilnehmer_aktion_buchen_api_dto Informationen zu einer Teilnehmerbuchung, die angelegt werden soll. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createVeranstaltungsterminBuchungUsingPOST1'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function createVeranstaltungsterminBuchungUsingPOST1Request($termin_id, $teilnehmer_aktion_buchen_api_dto = null, string $contentType = self::contentTypes['createVeranstaltungsterminBuchungUsingPOST1'][0])
    {

        // verify the required parameter 'termin_id' is set
        if ($termin_id === null || (is_array($termin_id) && count($termin_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $termin_id when calling createVeranstaltungsterminBuchungUsingPOST1'
            );
        }



        $resourcePath = '/v2/20010/veranstaltungstermine/{terminId}/buchen';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($termin_id !== null) {
            $resourcePath = str_replace(
                '{' . 'terminId' . '}',
                ObjectSerializer::toPathValue($termin_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($teilnehmer_aktion_buchen_api_dto)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($teilnehmer_aktion_buchen_api_dto));
            } else {
                $httpBody = $teilnehmer_aktion_buchen_api_dto;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getTeilnehmerbuchungenZuVeranstaltungsterminUsingGET
     *
     * Ermöglicht es, Teilnehmerbuchungen die den Status \&quot;Angemeldet\&quot;, \&quot;Eingeladen\&quot; oder \&quot;Bestätigt\&quot; gesetzt haben für einen Veranstaltungstermin abzurufen.
     *
     * @param  string $id ID des Veranstaltungstermins, zu dem die Teilnehmerbuchungen geladen werden sollen (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getTeilnehmerbuchungenZuVeranstaltungsterminUsingGET'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\TeilnehmerbuchungAbrufenApiDto[]
     */
    public function getTeilnehmerbuchungenZuVeranstaltungsterminUsingGET($id, string $contentType = self::contentTypes['getTeilnehmerbuchungenZuVeranstaltungsterminUsingGET'][0])
    {
        list($response) = $this->getTeilnehmerbuchungenZuVeranstaltungsterminUsingGETWithHttpInfo($id, $contentType);
        return $response;
    }

    /**
     * Operation getTeilnehmerbuchungenZuVeranstaltungsterminUsingGETWithHttpInfo
     *
     * Ermöglicht es, Teilnehmerbuchungen die den Status \&quot;Angemeldet\&quot;, \&quot;Eingeladen\&quot; oder \&quot;Bestätigt\&quot; gesetzt haben für einen Veranstaltungstermin abzurufen.
     *
     * @param  string $id ID des Veranstaltungstermins, zu dem die Teilnehmerbuchungen geladen werden sollen (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getTeilnehmerbuchungenZuVeranstaltungsterminUsingGET'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\TeilnehmerbuchungAbrufenApiDto[], HTTP status code, HTTP response headers (array of strings)
     */
    public function getTeilnehmerbuchungenZuVeranstaltungsterminUsingGETWithHttpInfo($id, string $contentType = self::contentTypes['getTeilnehmerbuchungenZuVeranstaltungsterminUsingGET'][0])
    {
        $request = $this->getTeilnehmerbuchungenZuVeranstaltungsterminUsingGETRequest($id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\TeilnehmerbuchungAbrufenApiDto[]' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\TeilnehmerbuchungAbrufenApiDto[]' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\TeilnehmerbuchungAbrufenApiDto[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\TeilnehmerbuchungAbrufenApiDto[]';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\TeilnehmerbuchungAbrufenApiDto[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getTeilnehmerbuchungenZuVeranstaltungsterminUsingGETAsync
     *
     * Ermöglicht es, Teilnehmerbuchungen die den Status \&quot;Angemeldet\&quot;, \&quot;Eingeladen\&quot; oder \&quot;Bestätigt\&quot; gesetzt haben für einen Veranstaltungstermin abzurufen.
     *
     * @param  string $id ID des Veranstaltungstermins, zu dem die Teilnehmerbuchungen geladen werden sollen (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getTeilnehmerbuchungenZuVeranstaltungsterminUsingGET'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getTeilnehmerbuchungenZuVeranstaltungsterminUsingGETAsync($id, string $contentType = self::contentTypes['getTeilnehmerbuchungenZuVeranstaltungsterminUsingGET'][0])
    {
        return $this->getTeilnehmerbuchungenZuVeranstaltungsterminUsingGETAsyncWithHttpInfo($id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getTeilnehmerbuchungenZuVeranstaltungsterminUsingGETAsyncWithHttpInfo
     *
     * Ermöglicht es, Teilnehmerbuchungen die den Status \&quot;Angemeldet\&quot;, \&quot;Eingeladen\&quot; oder \&quot;Bestätigt\&quot; gesetzt haben für einen Veranstaltungstermin abzurufen.
     *
     * @param  string $id ID des Veranstaltungstermins, zu dem die Teilnehmerbuchungen geladen werden sollen (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getTeilnehmerbuchungenZuVeranstaltungsterminUsingGET'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getTeilnehmerbuchungenZuVeranstaltungsterminUsingGETAsyncWithHttpInfo($id, string $contentType = self::contentTypes['getTeilnehmerbuchungenZuVeranstaltungsterminUsingGET'][0])
    {
        $returnType = '\OpenAPI\Client\Model\TeilnehmerbuchungAbrufenApiDto[]';
        $request = $this->getTeilnehmerbuchungenZuVeranstaltungsterminUsingGETRequest($id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getTeilnehmerbuchungenZuVeranstaltungsterminUsingGET'
     *
     * @param  string $id ID des Veranstaltungstermins, zu dem die Teilnehmerbuchungen geladen werden sollen (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getTeilnehmerbuchungenZuVeranstaltungsterminUsingGET'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getTeilnehmerbuchungenZuVeranstaltungsterminUsingGETRequest($id, string $contentType = self::contentTypes['getTeilnehmerbuchungenZuVeranstaltungsterminUsingGET'][0])
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling getTeilnehmerbuchungenZuVeranstaltungsterminUsingGET'
            );
        }


        $resourcePath = '/v2/veranstaltungstermine/{id}/teilnehmerbuchungen';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getTeilnehmerbuchungenZuVeranstaltungsterminUsingGET1
     *
     * Ermöglicht es, Teilnehmerbuchungen die den Status \&quot;Angemeldet\&quot;, \&quot;Eingeladen\&quot; oder \&quot;Bestätigt\&quot; gesetzt haben für einen Veranstaltungstermin abzurufen.
     *
     * @param  string $id ID des Veranstaltungstermins, zu dem die Teilnehmerbuchungen geladen werden sollen (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getTeilnehmerbuchungenZuVeranstaltungsterminUsingGET1'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\TeilnehmerbuchungAbrufenApiDto[]
     */
    public function getTeilnehmerbuchungenZuVeranstaltungsterminUsingGET1($id, string $contentType = self::contentTypes['getTeilnehmerbuchungenZuVeranstaltungsterminUsingGET1'][0])
    {
        list($response) = $this->getTeilnehmerbuchungenZuVeranstaltungsterminUsingGET1WithHttpInfo($id, $contentType);
        return $response;
    }

    /**
     * Operation getTeilnehmerbuchungenZuVeranstaltungsterminUsingGET1WithHttpInfo
     *
     * Ermöglicht es, Teilnehmerbuchungen die den Status \&quot;Angemeldet\&quot;, \&quot;Eingeladen\&quot; oder \&quot;Bestätigt\&quot; gesetzt haben für einen Veranstaltungstermin abzurufen.
     *
     * @param  string $id ID des Veranstaltungstermins, zu dem die Teilnehmerbuchungen geladen werden sollen (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getTeilnehmerbuchungenZuVeranstaltungsterminUsingGET1'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\TeilnehmerbuchungAbrufenApiDto[], HTTP status code, HTTP response headers (array of strings)
     */
    public function getTeilnehmerbuchungenZuVeranstaltungsterminUsingGET1WithHttpInfo($id, string $contentType = self::contentTypes['getTeilnehmerbuchungenZuVeranstaltungsterminUsingGET1'][0])
    {
        $request = $this->getTeilnehmerbuchungenZuVeranstaltungsterminUsingGET1Request($id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\TeilnehmerbuchungAbrufenApiDto[]' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\TeilnehmerbuchungAbrufenApiDto[]' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\TeilnehmerbuchungAbrufenApiDto[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\TeilnehmerbuchungAbrufenApiDto[]';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\TeilnehmerbuchungAbrufenApiDto[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getTeilnehmerbuchungenZuVeranstaltungsterminUsingGET1Async
     *
     * Ermöglicht es, Teilnehmerbuchungen die den Status \&quot;Angemeldet\&quot;, \&quot;Eingeladen\&quot; oder \&quot;Bestätigt\&quot; gesetzt haben für einen Veranstaltungstermin abzurufen.
     *
     * @param  string $id ID des Veranstaltungstermins, zu dem die Teilnehmerbuchungen geladen werden sollen (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getTeilnehmerbuchungenZuVeranstaltungsterminUsingGET1'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getTeilnehmerbuchungenZuVeranstaltungsterminUsingGET1Async($id, string $contentType = self::contentTypes['getTeilnehmerbuchungenZuVeranstaltungsterminUsingGET1'][0])
    {
        return $this->getTeilnehmerbuchungenZuVeranstaltungsterminUsingGET1AsyncWithHttpInfo($id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getTeilnehmerbuchungenZuVeranstaltungsterminUsingGET1AsyncWithHttpInfo
     *
     * Ermöglicht es, Teilnehmerbuchungen die den Status \&quot;Angemeldet\&quot;, \&quot;Eingeladen\&quot; oder \&quot;Bestätigt\&quot; gesetzt haben für einen Veranstaltungstermin abzurufen.
     *
     * @param  string $id ID des Veranstaltungstermins, zu dem die Teilnehmerbuchungen geladen werden sollen (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getTeilnehmerbuchungenZuVeranstaltungsterminUsingGET1'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getTeilnehmerbuchungenZuVeranstaltungsterminUsingGET1AsyncWithHttpInfo($id, string $contentType = self::contentTypes['getTeilnehmerbuchungenZuVeranstaltungsterminUsingGET1'][0])
    {
        $returnType = '\OpenAPI\Client\Model\TeilnehmerbuchungAbrufenApiDto[]';
        $request = $this->getTeilnehmerbuchungenZuVeranstaltungsterminUsingGET1Request($id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getTeilnehmerbuchungenZuVeranstaltungsterminUsingGET1'
     *
     * @param  string $id ID des Veranstaltungstermins, zu dem die Teilnehmerbuchungen geladen werden sollen (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getTeilnehmerbuchungenZuVeranstaltungsterminUsingGET1'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getTeilnehmerbuchungenZuVeranstaltungsterminUsingGET1Request($id, string $contentType = self::contentTypes['getTeilnehmerbuchungenZuVeranstaltungsterminUsingGET1'][0])
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling getTeilnehmerbuchungenZuVeranstaltungsterminUsingGET1'
            );
        }


        $resourcePath = '/v2/20010/veranstaltungstermine/{id}/teilnehmerbuchungen';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getVeranstaltungsterminUsingGET
     *
     * Ruft einen Veranstaltungstermin ab (entweder nicht storniert oder storniert)
     *
     * @param  string $id ID des Veranstaltungstermins (required)
     * @param  bool $stornierten_termin_abrufen Optionaler Parameter, um zu steuern, ob ein stornierter oder ein nicht stornierter Veranstaltungstermin abgerufen werden soll. Der Default ist false. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getVeranstaltungsterminUsingGET'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\Veranstaltungstermin
     */
    public function getVeranstaltungsterminUsingGET($id, $stornierten_termin_abrufen = null, string $contentType = self::contentTypes['getVeranstaltungsterminUsingGET'][0])
    {
        list($response) = $this->getVeranstaltungsterminUsingGETWithHttpInfo($id, $stornierten_termin_abrufen, $contentType);
        return $response;
    }

    /**
     * Operation getVeranstaltungsterminUsingGETWithHttpInfo
     *
     * Ruft einen Veranstaltungstermin ab (entweder nicht storniert oder storniert)
     *
     * @param  string $id ID des Veranstaltungstermins (required)
     * @param  bool $stornierten_termin_abrufen Optionaler Parameter, um zu steuern, ob ein stornierter oder ein nicht stornierter Veranstaltungstermin abgerufen werden soll. Der Default ist false. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getVeranstaltungsterminUsingGET'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\Veranstaltungstermin, HTTP status code, HTTP response headers (array of strings)
     */
    public function getVeranstaltungsterminUsingGETWithHttpInfo($id, $stornierten_termin_abrufen = null, string $contentType = self::contentTypes['getVeranstaltungsterminUsingGET'][0])
    {
        $request = $this->getVeranstaltungsterminUsingGETRequest($id, $stornierten_termin_abrufen, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\Veranstaltungstermin' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\Veranstaltungstermin' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\Veranstaltungstermin', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\Veranstaltungstermin';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\Veranstaltungstermin',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getVeranstaltungsterminUsingGETAsync
     *
     * Ruft einen Veranstaltungstermin ab (entweder nicht storniert oder storniert)
     *
     * @param  string $id ID des Veranstaltungstermins (required)
     * @param  bool $stornierten_termin_abrufen Optionaler Parameter, um zu steuern, ob ein stornierter oder ein nicht stornierter Veranstaltungstermin abgerufen werden soll. Der Default ist false. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getVeranstaltungsterminUsingGET'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getVeranstaltungsterminUsingGETAsync($id, $stornierten_termin_abrufen = null, string $contentType = self::contentTypes['getVeranstaltungsterminUsingGET'][0])
    {
        return $this->getVeranstaltungsterminUsingGETAsyncWithHttpInfo($id, $stornierten_termin_abrufen, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getVeranstaltungsterminUsingGETAsyncWithHttpInfo
     *
     * Ruft einen Veranstaltungstermin ab (entweder nicht storniert oder storniert)
     *
     * @param  string $id ID des Veranstaltungstermins (required)
     * @param  bool $stornierten_termin_abrufen Optionaler Parameter, um zu steuern, ob ein stornierter oder ein nicht stornierter Veranstaltungstermin abgerufen werden soll. Der Default ist false. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getVeranstaltungsterminUsingGET'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getVeranstaltungsterminUsingGETAsyncWithHttpInfo($id, $stornierten_termin_abrufen = null, string $contentType = self::contentTypes['getVeranstaltungsterminUsingGET'][0])
    {
        $returnType = '\OpenAPI\Client\Model\Veranstaltungstermin';
        $request = $this->getVeranstaltungsterminUsingGETRequest($id, $stornierten_termin_abrufen, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getVeranstaltungsterminUsingGET'
     *
     * @param  string $id ID des Veranstaltungstermins (required)
     * @param  bool $stornierten_termin_abrufen Optionaler Parameter, um zu steuern, ob ein stornierter oder ein nicht stornierter Veranstaltungstermin abgerufen werden soll. Der Default ist false. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getVeranstaltungsterminUsingGET'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getVeranstaltungsterminUsingGETRequest($id, $stornierten_termin_abrufen = null, string $contentType = self::contentTypes['getVeranstaltungsterminUsingGET'][0])
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling getVeranstaltungsterminUsingGET'
            );
        }



        $resourcePath = '/v2/veranstaltungstermine/{id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $stornierten_termin_abrufen,
            'storniertenTerminAbrufen', // param base name
            'boolean', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);


        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getVeranstaltungsterminUsingGET1
     *
     * Ruft einen Veranstaltungstermin ab (entweder nicht storniert oder storniert)
     *
     * @param  string $id ID des Veranstaltungstermins (required)
     * @param  bool $stornierten_termin_abrufen Optionaler Parameter, um zu steuern, ob ein stornierter oder ein nicht stornierter Veranstaltungstermin abgerufen werden soll. Der Default ist false. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getVeranstaltungsterminUsingGET1'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\VeranstaltungsterminSIGUV
     */
    public function getVeranstaltungsterminUsingGET1($id, $stornierten_termin_abrufen = null, string $contentType = self::contentTypes['getVeranstaltungsterminUsingGET1'][0])
    {
        list($response) = $this->getVeranstaltungsterminUsingGET1WithHttpInfo($id, $stornierten_termin_abrufen, $contentType);
        return $response;
    }

    /**
     * Operation getVeranstaltungsterminUsingGET1WithHttpInfo
     *
     * Ruft einen Veranstaltungstermin ab (entweder nicht storniert oder storniert)
     *
     * @param  string $id ID des Veranstaltungstermins (required)
     * @param  bool $stornierten_termin_abrufen Optionaler Parameter, um zu steuern, ob ein stornierter oder ein nicht stornierter Veranstaltungstermin abgerufen werden soll. Der Default ist false. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getVeranstaltungsterminUsingGET1'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\VeranstaltungsterminSIGUV, HTTP status code, HTTP response headers (array of strings)
     */
    public function getVeranstaltungsterminUsingGET1WithHttpInfo($id, $stornierten_termin_abrufen = null, string $contentType = self::contentTypes['getVeranstaltungsterminUsingGET1'][0])
    {
        $request = $this->getVeranstaltungsterminUsingGET1Request($id, $stornierten_termin_abrufen, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\VeranstaltungsterminSIGUV' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\VeranstaltungsterminSIGUV' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\VeranstaltungsterminSIGUV', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\VeranstaltungsterminSIGUV';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\VeranstaltungsterminSIGUV',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getVeranstaltungsterminUsingGET1Async
     *
     * Ruft einen Veranstaltungstermin ab (entweder nicht storniert oder storniert)
     *
     * @param  string $id ID des Veranstaltungstermins (required)
     * @param  bool $stornierten_termin_abrufen Optionaler Parameter, um zu steuern, ob ein stornierter oder ein nicht stornierter Veranstaltungstermin abgerufen werden soll. Der Default ist false. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getVeranstaltungsterminUsingGET1'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getVeranstaltungsterminUsingGET1Async($id, $stornierten_termin_abrufen = null, string $contentType = self::contentTypes['getVeranstaltungsterminUsingGET1'][0])
    {
        return $this->getVeranstaltungsterminUsingGET1AsyncWithHttpInfo($id, $stornierten_termin_abrufen, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getVeranstaltungsterminUsingGET1AsyncWithHttpInfo
     *
     * Ruft einen Veranstaltungstermin ab (entweder nicht storniert oder storniert)
     *
     * @param  string $id ID des Veranstaltungstermins (required)
     * @param  bool $stornierten_termin_abrufen Optionaler Parameter, um zu steuern, ob ein stornierter oder ein nicht stornierter Veranstaltungstermin abgerufen werden soll. Der Default ist false. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getVeranstaltungsterminUsingGET1'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getVeranstaltungsterminUsingGET1AsyncWithHttpInfo($id, $stornierten_termin_abrufen = null, string $contentType = self::contentTypes['getVeranstaltungsterminUsingGET1'][0])
    {
        $returnType = '\OpenAPI\Client\Model\VeranstaltungsterminSIGUV';
        $request = $this->getVeranstaltungsterminUsingGET1Request($id, $stornierten_termin_abrufen, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getVeranstaltungsterminUsingGET1'
     *
     * @param  string $id ID des Veranstaltungstermins (required)
     * @param  bool $stornierten_termin_abrufen Optionaler Parameter, um zu steuern, ob ein stornierter oder ein nicht stornierter Veranstaltungstermin abgerufen werden soll. Der Default ist false. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getVeranstaltungsterminUsingGET1'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getVeranstaltungsterminUsingGET1Request($id, $stornierten_termin_abrufen = null, string $contentType = self::contentTypes['getVeranstaltungsterminUsingGET1'][0])
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling getVeranstaltungsterminUsingGET1'
            );
        }



        $resourcePath = '/v2/20010/veranstaltungstermine/{id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $stornierten_termin_abrufen,
            'storniertenTerminAbrufen', // param base name
            'boolean', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);


        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getVeranstaltungstermineUsingGET
     *
     * Ruft Veranstaltungstermine ab (Websuche)
     *
     * @param  \OpenAPI\Client\Model\VeranstaltungsterminSuche $termin_suche_dto terminSucheDto (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getVeranstaltungstermineUsingGET'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\Veranstaltungstermin[]
     */
    public function getVeranstaltungstermineUsingGET($termin_suche_dto, string $contentType = self::contentTypes['getVeranstaltungstermineUsingGET'][0])
    {
        list($response) = $this->getVeranstaltungstermineUsingGETWithHttpInfo($termin_suche_dto, $contentType);
        return $response;
    }

    /**
     * Operation getVeranstaltungstermineUsingGETWithHttpInfo
     *
     * Ruft Veranstaltungstermine ab (Websuche)
     *
     * @param  \OpenAPI\Client\Model\VeranstaltungsterminSuche $termin_suche_dto terminSucheDto (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getVeranstaltungstermineUsingGET'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\Veranstaltungstermin[], HTTP status code, HTTP response headers (array of strings)
     */
    public function getVeranstaltungstermineUsingGETWithHttpInfo($termin_suche_dto, string $contentType = self::contentTypes['getVeranstaltungstermineUsingGET'][0])
    {
        $request = $this->getVeranstaltungstermineUsingGETRequest($termin_suche_dto, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\Veranstaltungstermin[]' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\Veranstaltungstermin[]' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\Veranstaltungstermin[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\Veranstaltungstermin[]';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\Veranstaltungstermin[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getVeranstaltungstermineUsingGETAsync
     *
     * Ruft Veranstaltungstermine ab (Websuche)
     *
     * @param  \OpenAPI\Client\Model\VeranstaltungsterminSuche $termin_suche_dto terminSucheDto (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getVeranstaltungstermineUsingGET'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getVeranstaltungstermineUsingGETAsync($termin_suche_dto, string $contentType = self::contentTypes['getVeranstaltungstermineUsingGET'][0])
    {
        return $this->getVeranstaltungstermineUsingGETAsyncWithHttpInfo($termin_suche_dto, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getVeranstaltungstermineUsingGETAsyncWithHttpInfo
     *
     * Ruft Veranstaltungstermine ab (Websuche)
     *
     * @param  \OpenAPI\Client\Model\VeranstaltungsterminSuche $termin_suche_dto terminSucheDto (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getVeranstaltungstermineUsingGET'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getVeranstaltungstermineUsingGETAsyncWithHttpInfo($termin_suche_dto, string $contentType = self::contentTypes['getVeranstaltungstermineUsingGET'][0])
    {
        $returnType = '\OpenAPI\Client\Model\Veranstaltungstermin[]';
        $request = $this->getVeranstaltungstermineUsingGETRequest($termin_suche_dto, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getVeranstaltungstermineUsingGET'
     *
     * @param  \OpenAPI\Client\Model\VeranstaltungsterminSuche $termin_suche_dto terminSucheDto (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getVeranstaltungstermineUsingGET'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getVeranstaltungstermineUsingGETRequest($termin_suche_dto, string $contentType = self::contentTypes['getVeranstaltungstermineUsingGET'][0])
    {

        // verify the required parameter 'termin_suche_dto' is set
        if ($termin_suche_dto === null || (is_array($termin_suche_dto) && count($termin_suche_dto) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $termin_suche_dto when calling getVeranstaltungstermineUsingGET'
            );
        }


        $resourcePath = '/v2/veranstaltungstermine/websuche';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($termin_suche_dto)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($termin_suche_dto));
            } else {
                $httpBody = $termin_suche_dto;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getVeranstaltungstermineUsingGET1
     *
     * Ruft Veranstaltungstermine ab (entweder nicht stornierte oder stornierte)
     *
     * @param  \DateTime $modifiziert_ab Änderungs- bzw. Einfügezeitpunkt, ab dem die Veranstaltungstermine geliefert werden sollen. Das Format muss wie folgt sein: yyyy-MM-ddTHH:mm:ss.SSS (optional)
     * @param  bool $stornierte_termine_abrufen Optionaler Parameter, um zu steuern, ob stornierte oder nicht stornierte Veranstaltungstermine abgerufen werden sollen. Der Default ist false. (optional)
     * @param  string $veranstaltungstyp_id Optionaler Parameter, um nur Veranstaltungstermine eines bestimmten Veranstaltungstyps abzurufen. Beispiel-ID: cfa1403a-13c6-4681-8ee3-e30127554845 (optional)
     * @param  string $teilnehmergruppekuerzel Optionaler Parameter, um zu steuern, für welche Teilnehmergruppe die Veranstaltungstermine abgerufen werden sollen. Ist eine Teilnehmergruppe angegeben, so werden alle in der Zukunft liegenden und publizierten Veranstaltungen für diese Teilnehmergruppe zurückgegeben. (optional)
     * @param  string $veranstaltungskategorie_id Optionaler Parameter, um Veranstaltungstermine nach einer Veranstaltungskategorie zu filtern. (optional)
     * @param  string $teilnehmer_plz Optionaler Parameter, um zu steuern, für welche PLZ (des Anmelders/Teilnehmers) passende Veranstaltungstermine abgerufen werden sollen. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getVeranstaltungstermineUsingGET1'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\Veranstaltungstermin[]
     */
    public function getVeranstaltungstermineUsingGET1($modifiziert_ab = null, $stornierte_termine_abrufen = null, $veranstaltungstyp_id = null, $teilnehmergruppekuerzel = null, $veranstaltungskategorie_id = null, $teilnehmer_plz = null, string $contentType = self::contentTypes['getVeranstaltungstermineUsingGET1'][0])
    {
        list($response) = $this->getVeranstaltungstermineUsingGET1WithHttpInfo($modifiziert_ab, $stornierte_termine_abrufen, $veranstaltungstyp_id, $teilnehmergruppekuerzel, $veranstaltungskategorie_id, $teilnehmer_plz, $contentType);
        return $response;
    }

    /**
     * Operation getVeranstaltungstermineUsingGET1WithHttpInfo
     *
     * Ruft Veranstaltungstermine ab (entweder nicht stornierte oder stornierte)
     *
     * @param  \DateTime $modifiziert_ab Änderungs- bzw. Einfügezeitpunkt, ab dem die Veranstaltungstermine geliefert werden sollen. Das Format muss wie folgt sein: yyyy-MM-ddTHH:mm:ss.SSS (optional)
     * @param  bool $stornierte_termine_abrufen Optionaler Parameter, um zu steuern, ob stornierte oder nicht stornierte Veranstaltungstermine abgerufen werden sollen. Der Default ist false. (optional)
     * @param  string $veranstaltungstyp_id Optionaler Parameter, um nur Veranstaltungstermine eines bestimmten Veranstaltungstyps abzurufen. Beispiel-ID: cfa1403a-13c6-4681-8ee3-e30127554845 (optional)
     * @param  string $teilnehmergruppekuerzel Optionaler Parameter, um zu steuern, für welche Teilnehmergruppe die Veranstaltungstermine abgerufen werden sollen. Ist eine Teilnehmergruppe angegeben, so werden alle in der Zukunft liegenden und publizierten Veranstaltungen für diese Teilnehmergruppe zurückgegeben. (optional)
     * @param  string $veranstaltungskategorie_id Optionaler Parameter, um Veranstaltungstermine nach einer Veranstaltungskategorie zu filtern. (optional)
     * @param  string $teilnehmer_plz Optionaler Parameter, um zu steuern, für welche PLZ (des Anmelders/Teilnehmers) passende Veranstaltungstermine abgerufen werden sollen. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getVeranstaltungstermineUsingGET1'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\Veranstaltungstermin[], HTTP status code, HTTP response headers (array of strings)
     */
    public function getVeranstaltungstermineUsingGET1WithHttpInfo($modifiziert_ab = null, $stornierte_termine_abrufen = null, $veranstaltungstyp_id = null, $teilnehmergruppekuerzel = null, $veranstaltungskategorie_id = null, $teilnehmer_plz = null, string $contentType = self::contentTypes['getVeranstaltungstermineUsingGET1'][0])
    {
        $request = $this->getVeranstaltungstermineUsingGET1Request($modifiziert_ab, $stornierte_termine_abrufen, $veranstaltungstyp_id, $teilnehmergruppekuerzel, $veranstaltungskategorie_id, $teilnehmer_plz, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\Veranstaltungstermin[]' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\Veranstaltungstermin[]' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\Veranstaltungstermin[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\Veranstaltungstermin[]';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\Veranstaltungstermin[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getVeranstaltungstermineUsingGET1Async
     *
     * Ruft Veranstaltungstermine ab (entweder nicht stornierte oder stornierte)
     *
     * @param  \DateTime $modifiziert_ab Änderungs- bzw. Einfügezeitpunkt, ab dem die Veranstaltungstermine geliefert werden sollen. Das Format muss wie folgt sein: yyyy-MM-ddTHH:mm:ss.SSS (optional)
     * @param  bool $stornierte_termine_abrufen Optionaler Parameter, um zu steuern, ob stornierte oder nicht stornierte Veranstaltungstermine abgerufen werden sollen. Der Default ist false. (optional)
     * @param  string $veranstaltungstyp_id Optionaler Parameter, um nur Veranstaltungstermine eines bestimmten Veranstaltungstyps abzurufen. Beispiel-ID: cfa1403a-13c6-4681-8ee3-e30127554845 (optional)
     * @param  string $teilnehmergruppekuerzel Optionaler Parameter, um zu steuern, für welche Teilnehmergruppe die Veranstaltungstermine abgerufen werden sollen. Ist eine Teilnehmergruppe angegeben, so werden alle in der Zukunft liegenden und publizierten Veranstaltungen für diese Teilnehmergruppe zurückgegeben. (optional)
     * @param  string $veranstaltungskategorie_id Optionaler Parameter, um Veranstaltungstermine nach einer Veranstaltungskategorie zu filtern. (optional)
     * @param  string $teilnehmer_plz Optionaler Parameter, um zu steuern, für welche PLZ (des Anmelders/Teilnehmers) passende Veranstaltungstermine abgerufen werden sollen. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getVeranstaltungstermineUsingGET1'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getVeranstaltungstermineUsingGET1Async($modifiziert_ab = null, $stornierte_termine_abrufen = null, $veranstaltungstyp_id = null, $teilnehmergruppekuerzel = null, $veranstaltungskategorie_id = null, $teilnehmer_plz = null, string $contentType = self::contentTypes['getVeranstaltungstermineUsingGET1'][0])
    {
        return $this->getVeranstaltungstermineUsingGET1AsyncWithHttpInfo($modifiziert_ab, $stornierte_termine_abrufen, $veranstaltungstyp_id, $teilnehmergruppekuerzel, $veranstaltungskategorie_id, $teilnehmer_plz, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getVeranstaltungstermineUsingGET1AsyncWithHttpInfo
     *
     * Ruft Veranstaltungstermine ab (entweder nicht stornierte oder stornierte)
     *
     * @param  \DateTime $modifiziert_ab Änderungs- bzw. Einfügezeitpunkt, ab dem die Veranstaltungstermine geliefert werden sollen. Das Format muss wie folgt sein: yyyy-MM-ddTHH:mm:ss.SSS (optional)
     * @param  bool $stornierte_termine_abrufen Optionaler Parameter, um zu steuern, ob stornierte oder nicht stornierte Veranstaltungstermine abgerufen werden sollen. Der Default ist false. (optional)
     * @param  string $veranstaltungstyp_id Optionaler Parameter, um nur Veranstaltungstermine eines bestimmten Veranstaltungstyps abzurufen. Beispiel-ID: cfa1403a-13c6-4681-8ee3-e30127554845 (optional)
     * @param  string $teilnehmergruppekuerzel Optionaler Parameter, um zu steuern, für welche Teilnehmergruppe die Veranstaltungstermine abgerufen werden sollen. Ist eine Teilnehmergruppe angegeben, so werden alle in der Zukunft liegenden und publizierten Veranstaltungen für diese Teilnehmergruppe zurückgegeben. (optional)
     * @param  string $veranstaltungskategorie_id Optionaler Parameter, um Veranstaltungstermine nach einer Veranstaltungskategorie zu filtern. (optional)
     * @param  string $teilnehmer_plz Optionaler Parameter, um zu steuern, für welche PLZ (des Anmelders/Teilnehmers) passende Veranstaltungstermine abgerufen werden sollen. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getVeranstaltungstermineUsingGET1'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getVeranstaltungstermineUsingGET1AsyncWithHttpInfo($modifiziert_ab = null, $stornierte_termine_abrufen = null, $veranstaltungstyp_id = null, $teilnehmergruppekuerzel = null, $veranstaltungskategorie_id = null, $teilnehmer_plz = null, string $contentType = self::contentTypes['getVeranstaltungstermineUsingGET1'][0])
    {
        $returnType = '\OpenAPI\Client\Model\Veranstaltungstermin[]';
        $request = $this->getVeranstaltungstermineUsingGET1Request($modifiziert_ab, $stornierte_termine_abrufen, $veranstaltungstyp_id, $teilnehmergruppekuerzel, $veranstaltungskategorie_id, $teilnehmer_plz, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getVeranstaltungstermineUsingGET1'
     *
     * @param  \DateTime $modifiziert_ab Änderungs- bzw. Einfügezeitpunkt, ab dem die Veranstaltungstermine geliefert werden sollen. Das Format muss wie folgt sein: yyyy-MM-ddTHH:mm:ss.SSS (optional)
     * @param  bool $stornierte_termine_abrufen Optionaler Parameter, um zu steuern, ob stornierte oder nicht stornierte Veranstaltungstermine abgerufen werden sollen. Der Default ist false. (optional)
     * @param  string $veranstaltungstyp_id Optionaler Parameter, um nur Veranstaltungstermine eines bestimmten Veranstaltungstyps abzurufen. Beispiel-ID: cfa1403a-13c6-4681-8ee3-e30127554845 (optional)
     * @param  string $teilnehmergruppekuerzel Optionaler Parameter, um zu steuern, für welche Teilnehmergruppe die Veranstaltungstermine abgerufen werden sollen. Ist eine Teilnehmergruppe angegeben, so werden alle in der Zukunft liegenden und publizierten Veranstaltungen für diese Teilnehmergruppe zurückgegeben. (optional)
     * @param  string $veranstaltungskategorie_id Optionaler Parameter, um Veranstaltungstermine nach einer Veranstaltungskategorie zu filtern. (optional)
     * @param  string $teilnehmer_plz Optionaler Parameter, um zu steuern, für welche PLZ (des Anmelders/Teilnehmers) passende Veranstaltungstermine abgerufen werden sollen. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getVeranstaltungstermineUsingGET1'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getVeranstaltungstermineUsingGET1Request($modifiziert_ab = null, $stornierte_termine_abrufen = null, $veranstaltungstyp_id = null, $teilnehmergruppekuerzel = null, $veranstaltungskategorie_id = null, $teilnehmer_plz = null, string $contentType = self::contentTypes['getVeranstaltungstermineUsingGET1'][0])
    {








        $resourcePath = '/v2/veranstaltungstermine';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $modifiziert_ab,
            'modifiziertAb', // param base name
            'string', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $stornierte_termine_abrufen,
            'stornierteTermineAbrufen', // param base name
            'boolean', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $veranstaltungstyp_id,
            'veranstaltungstypID', // param base name
            'string', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $teilnehmergruppekuerzel,
            'teilnehmergruppekuerzel', // param base name
            'string', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $veranstaltungskategorie_id,
            'veranstaltungskategorieId', // param base name
            'string', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $teilnehmer_plz,
            'teilnehmerPlz', // param base name
            'string', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);




        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getVeranstaltungstermineUsingGET2
     *
     * Ruft Veranstaltungstermine ab (Websuche)
     *
     * @param  \OpenAPI\Client\Model\VeranstaltungsterminSuche $termin_suche_dto terminSucheDto (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getVeranstaltungstermineUsingGET2'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\Veranstaltungstermin[]
     */
    public function getVeranstaltungstermineUsingGET2($termin_suche_dto, string $contentType = self::contentTypes['getVeranstaltungstermineUsingGET2'][0])
    {
        list($response) = $this->getVeranstaltungstermineUsingGET2WithHttpInfo($termin_suche_dto, $contentType);
        return $response;
    }

    /**
     * Operation getVeranstaltungstermineUsingGET2WithHttpInfo
     *
     * Ruft Veranstaltungstermine ab (Websuche)
     *
     * @param  \OpenAPI\Client\Model\VeranstaltungsterminSuche $termin_suche_dto terminSucheDto (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getVeranstaltungstermineUsingGET2'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\Veranstaltungstermin[], HTTP status code, HTTP response headers (array of strings)
     */
    public function getVeranstaltungstermineUsingGET2WithHttpInfo($termin_suche_dto, string $contentType = self::contentTypes['getVeranstaltungstermineUsingGET2'][0])
    {
        $request = $this->getVeranstaltungstermineUsingGET2Request($termin_suche_dto, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\Veranstaltungstermin[]' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\Veranstaltungstermin[]' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\Veranstaltungstermin[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\Veranstaltungstermin[]';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\Veranstaltungstermin[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getVeranstaltungstermineUsingGET2Async
     *
     * Ruft Veranstaltungstermine ab (Websuche)
     *
     * @param  \OpenAPI\Client\Model\VeranstaltungsterminSuche $termin_suche_dto terminSucheDto (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getVeranstaltungstermineUsingGET2'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getVeranstaltungstermineUsingGET2Async($termin_suche_dto, string $contentType = self::contentTypes['getVeranstaltungstermineUsingGET2'][0])
    {
        return $this->getVeranstaltungstermineUsingGET2AsyncWithHttpInfo($termin_suche_dto, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getVeranstaltungstermineUsingGET2AsyncWithHttpInfo
     *
     * Ruft Veranstaltungstermine ab (Websuche)
     *
     * @param  \OpenAPI\Client\Model\VeranstaltungsterminSuche $termin_suche_dto terminSucheDto (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getVeranstaltungstermineUsingGET2'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getVeranstaltungstermineUsingGET2AsyncWithHttpInfo($termin_suche_dto, string $contentType = self::contentTypes['getVeranstaltungstermineUsingGET2'][0])
    {
        $returnType = '\OpenAPI\Client\Model\Veranstaltungstermin[]';
        $request = $this->getVeranstaltungstermineUsingGET2Request($termin_suche_dto, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getVeranstaltungstermineUsingGET2'
     *
     * @param  \OpenAPI\Client\Model\VeranstaltungsterminSuche $termin_suche_dto terminSucheDto (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getVeranstaltungstermineUsingGET2'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getVeranstaltungstermineUsingGET2Request($termin_suche_dto, string $contentType = self::contentTypes['getVeranstaltungstermineUsingGET2'][0])
    {

        // verify the required parameter 'termin_suche_dto' is set
        if ($termin_suche_dto === null || (is_array($termin_suche_dto) && count($termin_suche_dto) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $termin_suche_dto when calling getVeranstaltungstermineUsingGET2'
            );
        }


        $resourcePath = '/v2/20010/veranstaltungstermine/websuche';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($termin_suche_dto)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($termin_suche_dto));
            } else {
                $httpBody = $termin_suche_dto;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getVeranstaltungstermineUsingGET3
     *
     * Ruft Veranstaltungstermine ab (entweder nicht stornierte oder stornierte)
     *
     * @param  \DateTime $modifiziert_ab Änderungs- bzw. Einfügezeitpunkt, ab dem die Veranstaltungstermine geliefert werden sollen. Das Format muss wie folgt sein: yyyy-MM-ddTHH:mm:ss.SSS (optional)
     * @param  bool $stornierte_termine_abrufen Optionaler Parameter, um zu steuern, ob stornierte oder nicht stornierte Veranstaltungstermine abgerufen werden sollen. Der Default ist false. (optional)
     * @param  string $veranstaltungstyp_id Optionaler Parameter, um nur Veranstaltungstermine eines bestimmten Veranstaltungstyps abzurufen. Beispiel-ID: cfa1403a-13c6-4681-8ee3-e30127554845 (optional)
     * @param  string $teilnehmergruppekuerzel Optionaler Parameter, um zu steuern, für welche Teilnehmergruppe die Veranstaltungstermine abgerufen werden sollen. Ist eine Teilnehmergruppe angegeben, so werden alle in der Zukunft liegenden und publizierten Veranstaltungen für diese Teilnehmergruppe zurückgegeben. (optional)
     * @param  string $veranstaltungskategorie_id Optionaler Parameter, um Veranstaltungstermine nach einer Veranstaltungskategorie zu filtern. (optional)
     * @param  string $teilnehmer_plz Optionaler Parameter, um zu steuern, für welche PLZ (des Anmelders/Teilnehmers) die Veranstaltungstermine abgerufen werden sollen. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getVeranstaltungstermineUsingGET3'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\VeranstaltungsterminSIGUV[]
     */
    public function getVeranstaltungstermineUsingGET3($modifiziert_ab = null, $stornierte_termine_abrufen = null, $veranstaltungstyp_id = null, $teilnehmergruppekuerzel = null, $veranstaltungskategorie_id = null, $teilnehmer_plz = null, string $contentType = self::contentTypes['getVeranstaltungstermineUsingGET3'][0])
    {
        list($response) = $this->getVeranstaltungstermineUsingGET3WithHttpInfo($modifiziert_ab, $stornierte_termine_abrufen, $veranstaltungstyp_id, $teilnehmergruppekuerzel, $veranstaltungskategorie_id, $teilnehmer_plz, $contentType);
        return $response;
    }

    /**
     * Operation getVeranstaltungstermineUsingGET3WithHttpInfo
     *
     * Ruft Veranstaltungstermine ab (entweder nicht stornierte oder stornierte)
     *
     * @param  \DateTime $modifiziert_ab Änderungs- bzw. Einfügezeitpunkt, ab dem die Veranstaltungstermine geliefert werden sollen. Das Format muss wie folgt sein: yyyy-MM-ddTHH:mm:ss.SSS (optional)
     * @param  bool $stornierte_termine_abrufen Optionaler Parameter, um zu steuern, ob stornierte oder nicht stornierte Veranstaltungstermine abgerufen werden sollen. Der Default ist false. (optional)
     * @param  string $veranstaltungstyp_id Optionaler Parameter, um nur Veranstaltungstermine eines bestimmten Veranstaltungstyps abzurufen. Beispiel-ID: cfa1403a-13c6-4681-8ee3-e30127554845 (optional)
     * @param  string $teilnehmergruppekuerzel Optionaler Parameter, um zu steuern, für welche Teilnehmergruppe die Veranstaltungstermine abgerufen werden sollen. Ist eine Teilnehmergruppe angegeben, so werden alle in der Zukunft liegenden und publizierten Veranstaltungen für diese Teilnehmergruppe zurückgegeben. (optional)
     * @param  string $veranstaltungskategorie_id Optionaler Parameter, um Veranstaltungstermine nach einer Veranstaltungskategorie zu filtern. (optional)
     * @param  string $teilnehmer_plz Optionaler Parameter, um zu steuern, für welche PLZ (des Anmelders/Teilnehmers) die Veranstaltungstermine abgerufen werden sollen. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getVeranstaltungstermineUsingGET3'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\VeranstaltungsterminSIGUV[], HTTP status code, HTTP response headers (array of strings)
     */
    public function getVeranstaltungstermineUsingGET3WithHttpInfo($modifiziert_ab = null, $stornierte_termine_abrufen = null, $veranstaltungstyp_id = null, $teilnehmergruppekuerzel = null, $veranstaltungskategorie_id = null, $teilnehmer_plz = null, string $contentType = self::contentTypes['getVeranstaltungstermineUsingGET3'][0])
    {
        $request = $this->getVeranstaltungstermineUsingGET3Request($modifiziert_ab, $stornierte_termine_abrufen, $veranstaltungstyp_id, $teilnehmergruppekuerzel, $veranstaltungskategorie_id, $teilnehmer_plz, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\VeranstaltungsterminSIGUV[]' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\VeranstaltungsterminSIGUV[]' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\VeranstaltungsterminSIGUV[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\VeranstaltungsterminSIGUV[]';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\VeranstaltungsterminSIGUV[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getVeranstaltungstermineUsingGET3Async
     *
     * Ruft Veranstaltungstermine ab (entweder nicht stornierte oder stornierte)
     *
     * @param  \DateTime $modifiziert_ab Änderungs- bzw. Einfügezeitpunkt, ab dem die Veranstaltungstermine geliefert werden sollen. Das Format muss wie folgt sein: yyyy-MM-ddTHH:mm:ss.SSS (optional)
     * @param  bool $stornierte_termine_abrufen Optionaler Parameter, um zu steuern, ob stornierte oder nicht stornierte Veranstaltungstermine abgerufen werden sollen. Der Default ist false. (optional)
     * @param  string $veranstaltungstyp_id Optionaler Parameter, um nur Veranstaltungstermine eines bestimmten Veranstaltungstyps abzurufen. Beispiel-ID: cfa1403a-13c6-4681-8ee3-e30127554845 (optional)
     * @param  string $teilnehmergruppekuerzel Optionaler Parameter, um zu steuern, für welche Teilnehmergruppe die Veranstaltungstermine abgerufen werden sollen. Ist eine Teilnehmergruppe angegeben, so werden alle in der Zukunft liegenden und publizierten Veranstaltungen für diese Teilnehmergruppe zurückgegeben. (optional)
     * @param  string $veranstaltungskategorie_id Optionaler Parameter, um Veranstaltungstermine nach einer Veranstaltungskategorie zu filtern. (optional)
     * @param  string $teilnehmer_plz Optionaler Parameter, um zu steuern, für welche PLZ (des Anmelders/Teilnehmers) die Veranstaltungstermine abgerufen werden sollen. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getVeranstaltungstermineUsingGET3'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getVeranstaltungstermineUsingGET3Async($modifiziert_ab = null, $stornierte_termine_abrufen = null, $veranstaltungstyp_id = null, $teilnehmergruppekuerzel = null, $veranstaltungskategorie_id = null, $teilnehmer_plz = null, string $contentType = self::contentTypes['getVeranstaltungstermineUsingGET3'][0])
    {
        return $this->getVeranstaltungstermineUsingGET3AsyncWithHttpInfo($modifiziert_ab, $stornierte_termine_abrufen, $veranstaltungstyp_id, $teilnehmergruppekuerzel, $veranstaltungskategorie_id, $teilnehmer_plz, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getVeranstaltungstermineUsingGET3AsyncWithHttpInfo
     *
     * Ruft Veranstaltungstermine ab (entweder nicht stornierte oder stornierte)
     *
     * @param  \DateTime $modifiziert_ab Änderungs- bzw. Einfügezeitpunkt, ab dem die Veranstaltungstermine geliefert werden sollen. Das Format muss wie folgt sein: yyyy-MM-ddTHH:mm:ss.SSS (optional)
     * @param  bool $stornierte_termine_abrufen Optionaler Parameter, um zu steuern, ob stornierte oder nicht stornierte Veranstaltungstermine abgerufen werden sollen. Der Default ist false. (optional)
     * @param  string $veranstaltungstyp_id Optionaler Parameter, um nur Veranstaltungstermine eines bestimmten Veranstaltungstyps abzurufen. Beispiel-ID: cfa1403a-13c6-4681-8ee3-e30127554845 (optional)
     * @param  string $teilnehmergruppekuerzel Optionaler Parameter, um zu steuern, für welche Teilnehmergruppe die Veranstaltungstermine abgerufen werden sollen. Ist eine Teilnehmergruppe angegeben, so werden alle in der Zukunft liegenden und publizierten Veranstaltungen für diese Teilnehmergruppe zurückgegeben. (optional)
     * @param  string $veranstaltungskategorie_id Optionaler Parameter, um Veranstaltungstermine nach einer Veranstaltungskategorie zu filtern. (optional)
     * @param  string $teilnehmer_plz Optionaler Parameter, um zu steuern, für welche PLZ (des Anmelders/Teilnehmers) die Veranstaltungstermine abgerufen werden sollen. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getVeranstaltungstermineUsingGET3'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getVeranstaltungstermineUsingGET3AsyncWithHttpInfo($modifiziert_ab = null, $stornierte_termine_abrufen = null, $veranstaltungstyp_id = null, $teilnehmergruppekuerzel = null, $veranstaltungskategorie_id = null, $teilnehmer_plz = null, string $contentType = self::contentTypes['getVeranstaltungstermineUsingGET3'][0])
    {
        $returnType = '\OpenAPI\Client\Model\VeranstaltungsterminSIGUV[]';
        $request = $this->getVeranstaltungstermineUsingGET3Request($modifiziert_ab, $stornierte_termine_abrufen, $veranstaltungstyp_id, $teilnehmergruppekuerzel, $veranstaltungskategorie_id, $teilnehmer_plz, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getVeranstaltungstermineUsingGET3'
     *
     * @param  \DateTime $modifiziert_ab Änderungs- bzw. Einfügezeitpunkt, ab dem die Veranstaltungstermine geliefert werden sollen. Das Format muss wie folgt sein: yyyy-MM-ddTHH:mm:ss.SSS (optional)
     * @param  bool $stornierte_termine_abrufen Optionaler Parameter, um zu steuern, ob stornierte oder nicht stornierte Veranstaltungstermine abgerufen werden sollen. Der Default ist false. (optional)
     * @param  string $veranstaltungstyp_id Optionaler Parameter, um nur Veranstaltungstermine eines bestimmten Veranstaltungstyps abzurufen. Beispiel-ID: cfa1403a-13c6-4681-8ee3-e30127554845 (optional)
     * @param  string $teilnehmergruppekuerzel Optionaler Parameter, um zu steuern, für welche Teilnehmergruppe die Veranstaltungstermine abgerufen werden sollen. Ist eine Teilnehmergruppe angegeben, so werden alle in der Zukunft liegenden und publizierten Veranstaltungen für diese Teilnehmergruppe zurückgegeben. (optional)
     * @param  string $veranstaltungskategorie_id Optionaler Parameter, um Veranstaltungstermine nach einer Veranstaltungskategorie zu filtern. (optional)
     * @param  string $teilnehmer_plz Optionaler Parameter, um zu steuern, für welche PLZ (des Anmelders/Teilnehmers) die Veranstaltungstermine abgerufen werden sollen. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getVeranstaltungstermineUsingGET3'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getVeranstaltungstermineUsingGET3Request($modifiziert_ab = null, $stornierte_termine_abrufen = null, $veranstaltungstyp_id = null, $teilnehmergruppekuerzel = null, $veranstaltungskategorie_id = null, $teilnehmer_plz = null, string $contentType = self::contentTypes['getVeranstaltungstermineUsingGET3'][0])
    {








        $resourcePath = '/v2/20010/veranstaltungstermine';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $modifiziert_ab,
            'modifiziertAb', // param base name
            'string', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $stornierte_termine_abrufen,
            'stornierteTermineAbrufen', // param base name
            'boolean', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $veranstaltungstyp_id,
            'veranstaltungstypID', // param base name
            'string', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $teilnehmergruppekuerzel,
            'teilnehmergruppekuerzel', // param base name
            'string', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $veranstaltungskategorie_id,
            'veranstaltungskategorieId', // param base name
            'string', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $teilnehmer_plz,
            'teilnehmerPlz', // param base name
            'string', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);




        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getVeranstaltungstypPlzBereicheUsingGET
     *
     * Ruft Postleitzahl-Bereiche der Veranstaltungstermine ab
     *
     * @param  string $teilnehmergruppekuerzel Parameter, um zu steuern, für welche Teilnehmergruppe die PLZ-Bereiche abgerufen werden sollen. Es werden nur PLZ-Bereiche der für diese Teilnehmergruppe publizierten Veranstaltungstermine zurückgegeben. (optional)
     * @param  string $veranstaltungstyp_nr Optionaler Parameter für die Nummer des Veranstaltungstypen. (optional)
     * @param  string $veranstaltungstyp_id Optionaler Parameter für die ID des Veranstaltungstypen. (optional)
     * @param  string $veranstaltungstermin_id Optionaler Parameter für die ID des Veranstaltungstermins. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getVeranstaltungstypPlzBereicheUsingGET'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\PLZBereichVeranstaltungstermin[]
     */
    public function getVeranstaltungstypPlzBereicheUsingGET($teilnehmergruppekuerzel = null, $veranstaltungstyp_nr = null, $veranstaltungstyp_id = null, $veranstaltungstermin_id = null, string $contentType = self::contentTypes['getVeranstaltungstypPlzBereicheUsingGET'][0])
    {
        list($response) = $this->getVeranstaltungstypPlzBereicheUsingGETWithHttpInfo($teilnehmergruppekuerzel, $veranstaltungstyp_nr, $veranstaltungstyp_id, $veranstaltungstermin_id, $contentType);
        return $response;
    }

    /**
     * Operation getVeranstaltungstypPlzBereicheUsingGETWithHttpInfo
     *
     * Ruft Postleitzahl-Bereiche der Veranstaltungstermine ab
     *
     * @param  string $teilnehmergruppekuerzel Parameter, um zu steuern, für welche Teilnehmergruppe die PLZ-Bereiche abgerufen werden sollen. Es werden nur PLZ-Bereiche der für diese Teilnehmergruppe publizierten Veranstaltungstermine zurückgegeben. (optional)
     * @param  string $veranstaltungstyp_nr Optionaler Parameter für die Nummer des Veranstaltungstypen. (optional)
     * @param  string $veranstaltungstyp_id Optionaler Parameter für die ID des Veranstaltungstypen. (optional)
     * @param  string $veranstaltungstermin_id Optionaler Parameter für die ID des Veranstaltungstermins. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getVeranstaltungstypPlzBereicheUsingGET'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\PLZBereichVeranstaltungstermin[], HTTP status code, HTTP response headers (array of strings)
     */
    public function getVeranstaltungstypPlzBereicheUsingGETWithHttpInfo($teilnehmergruppekuerzel = null, $veranstaltungstyp_nr = null, $veranstaltungstyp_id = null, $veranstaltungstermin_id = null, string $contentType = self::contentTypes['getVeranstaltungstypPlzBereicheUsingGET'][0])
    {
        $request = $this->getVeranstaltungstypPlzBereicheUsingGETRequest($teilnehmergruppekuerzel, $veranstaltungstyp_nr, $veranstaltungstyp_id, $veranstaltungstermin_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\PLZBereichVeranstaltungstermin[]' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\PLZBereichVeranstaltungstermin[]' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\PLZBereichVeranstaltungstermin[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\PLZBereichVeranstaltungstermin[]';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\PLZBereichVeranstaltungstermin[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getVeranstaltungstypPlzBereicheUsingGETAsync
     *
     * Ruft Postleitzahl-Bereiche der Veranstaltungstermine ab
     *
     * @param  string $teilnehmergruppekuerzel Parameter, um zu steuern, für welche Teilnehmergruppe die PLZ-Bereiche abgerufen werden sollen. Es werden nur PLZ-Bereiche der für diese Teilnehmergruppe publizierten Veranstaltungstermine zurückgegeben. (optional)
     * @param  string $veranstaltungstyp_nr Optionaler Parameter für die Nummer des Veranstaltungstypen. (optional)
     * @param  string $veranstaltungstyp_id Optionaler Parameter für die ID des Veranstaltungstypen. (optional)
     * @param  string $veranstaltungstermin_id Optionaler Parameter für die ID des Veranstaltungstermins. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getVeranstaltungstypPlzBereicheUsingGET'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getVeranstaltungstypPlzBereicheUsingGETAsync($teilnehmergruppekuerzel = null, $veranstaltungstyp_nr = null, $veranstaltungstyp_id = null, $veranstaltungstermin_id = null, string $contentType = self::contentTypes['getVeranstaltungstypPlzBereicheUsingGET'][0])
    {
        return $this->getVeranstaltungstypPlzBereicheUsingGETAsyncWithHttpInfo($teilnehmergruppekuerzel, $veranstaltungstyp_nr, $veranstaltungstyp_id, $veranstaltungstermin_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getVeranstaltungstypPlzBereicheUsingGETAsyncWithHttpInfo
     *
     * Ruft Postleitzahl-Bereiche der Veranstaltungstermine ab
     *
     * @param  string $teilnehmergruppekuerzel Parameter, um zu steuern, für welche Teilnehmergruppe die PLZ-Bereiche abgerufen werden sollen. Es werden nur PLZ-Bereiche der für diese Teilnehmergruppe publizierten Veranstaltungstermine zurückgegeben. (optional)
     * @param  string $veranstaltungstyp_nr Optionaler Parameter für die Nummer des Veranstaltungstypen. (optional)
     * @param  string $veranstaltungstyp_id Optionaler Parameter für die ID des Veranstaltungstypen. (optional)
     * @param  string $veranstaltungstermin_id Optionaler Parameter für die ID des Veranstaltungstermins. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getVeranstaltungstypPlzBereicheUsingGET'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getVeranstaltungstypPlzBereicheUsingGETAsyncWithHttpInfo($teilnehmergruppekuerzel = null, $veranstaltungstyp_nr = null, $veranstaltungstyp_id = null, $veranstaltungstermin_id = null, string $contentType = self::contentTypes['getVeranstaltungstypPlzBereicheUsingGET'][0])
    {
        $returnType = '\OpenAPI\Client\Model\PLZBereichVeranstaltungstermin[]';
        $request = $this->getVeranstaltungstypPlzBereicheUsingGETRequest($teilnehmergruppekuerzel, $veranstaltungstyp_nr, $veranstaltungstyp_id, $veranstaltungstermin_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getVeranstaltungstypPlzBereicheUsingGET'
     *
     * @param  string $teilnehmergruppekuerzel Parameter, um zu steuern, für welche Teilnehmergruppe die PLZ-Bereiche abgerufen werden sollen. Es werden nur PLZ-Bereiche der für diese Teilnehmergruppe publizierten Veranstaltungstermine zurückgegeben. (optional)
     * @param  string $veranstaltungstyp_nr Optionaler Parameter für die Nummer des Veranstaltungstypen. (optional)
     * @param  string $veranstaltungstyp_id Optionaler Parameter für die ID des Veranstaltungstypen. (optional)
     * @param  string $veranstaltungstermin_id Optionaler Parameter für die ID des Veranstaltungstermins. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getVeranstaltungstypPlzBereicheUsingGET'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getVeranstaltungstypPlzBereicheUsingGETRequest($teilnehmergruppekuerzel = null, $veranstaltungstyp_nr = null, $veranstaltungstyp_id = null, $veranstaltungstermin_id = null, string $contentType = self::contentTypes['getVeranstaltungstypPlzBereicheUsingGET'][0])
    {






        $resourcePath = '/v2/veranstaltungstermine/plzbereiche';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $teilnehmergruppekuerzel,
            'teilnehmergruppekuerzel', // param base name
            'string', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $veranstaltungstyp_nr,
            'veranstaltungstypNr', // param base name
            'string', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $veranstaltungstyp_id,
            'veranstaltungstypID', // param base name
            'string', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $veranstaltungstermin_id,
            'veranstaltungsterminID', // param base name
            'string', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);




        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Create http client option
     *
     * @throws \RuntimeException on file opening failure
     * @return array of http client options
     */
    protected function createHttpClientOption()
    {
        $options = [];
        if ($this->config->getDebug()) {
            $options[RequestOptions::DEBUG] = fopen($this->config->getDebugFile(), 'a');
            if (!$options[RequestOptions::DEBUG]) {
                throw new \RuntimeException('Failed to open the debug file: ' . $this->config->getDebugFile());
            }
        }

        return $options;
    }
}
